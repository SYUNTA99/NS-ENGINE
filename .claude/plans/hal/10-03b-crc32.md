# 10-03b: CRC32実装

## 目的

CRC32ハッシュ関数と文字列ハッシュを実装する。

## 参考

[Platform_Abstraction_Layer_Part10.md](docs/Platform_Abstraction_Layer_Part10.md) - セクション3「ハッシュ関数」

## 依存（commonモジュール）

- `common/utility/types.h` - 基本型（`uint32`）

## 依存（HAL）

- 01-04 プラットフォーム型（`SIZE_T`, `ANSICHAR`, `WIDECHAR`, `TCHAR`）
- 10-03a GetTypeHashテンプレート

## 変更対象

変更:
- `source/engine/hal/Public/HAL/Hash.h`（関数宣言追加）

新規作成:
- `source/engine/hal/Private/HAL/Hash.cpp`

## TODO

- [ ] CRC32テーブル生成
- [ ] `Crc32` バイト配列版
- [ ] `StrCrc32` ANSI文字列版
- [ ] `StrCrc32` ワイド文字列版
- [ ] SSE4.2 CRC32命令対応（オプション）

## 実装内容

### Hash.h（追加）

```cpp
// Hash.h に追加

namespace NS
{
    /// CRC32ハッシュ計算
    /// @param data データポインタ
    /// @param length データ長（バイト）
    /// @param crc 初期CRC値（連続計算用）
    /// @return CRC32値
    uint32 Crc32(const void* data, SIZE_T length, uint32 crc = 0);

    /// ANSI文字列のCRC32ハッシュ
    uint32 StrCrc32(const ANSICHAR* str);

    /// ワイド文字列のCRC32ハッシュ
    uint32 StrCrc32(const WIDECHAR* str);

    /// TCHAR文字列のCRC32ハッシュ
    inline uint32 StrCrc32(const TCHAR* str)
    {
        if constexpr (sizeof(TCHAR) == sizeof(WIDECHAR))
        {
            return StrCrc32(reinterpret_cast<const WIDECHAR*>(str));
        }
        else
        {
            return StrCrc32(reinterpret_cast<const ANSICHAR*>(str));
        }
    }

    /// 大文字小文字無視のANSI文字列ハッシュ
    uint32 StrCrc32NoCase(const ANSICHAR* str);

    /// 大文字小文字無視のワイド文字列ハッシュ
    uint32 StrCrc32NoCase(const WIDECHAR* str);
}
```

### Hash.cpp

```cpp
#include "HAL/Hash.h"
#include "HAL/Char.h"

namespace NS
{
    // CRC32テーブル（IEEE 802.3多項式: 0xEDB88320）
    static const uint32 s_crc32Table[256] = {
        0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
        0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
        0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
        0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
        // ... 残り252エントリ（完全なテーブルは省略）
        0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
    };

    // テーブル初期化（コンパイル時に生成する場合はconstexpr版を使用）
    static uint32 ComputeCrc32TableEntry(uint32 index)
    {
        uint32 crc = index;
        for (int bit = 0; bit < 8; ++bit)
        {
            if (crc & 1)
            {
                crc = (crc >> 1) ^ 0xEDB88320;
            }
            else
            {
                crc >>= 1;
            }
        }
        return crc;
    }

    uint32 Crc32(const void* data, SIZE_T length, uint32 crc)
    {
        const uint8* bytes = static_cast<const uint8*>(data);
        crc = ~crc;

        for (SIZE_T i = 0; i < length; ++i)
        {
            crc = s_crc32Table[(crc ^ bytes[i]) & 0xFF] ^ (crc >> 8);
        }

        return ~crc;
    }

    uint32 StrCrc32(const ANSICHAR* str)
    {
        if (str == nullptr)
        {
            return 0;
        }

        uint32 crc = ~0U;
        while (*str)
        {
            crc = s_crc32Table[(crc ^ static_cast<uint8>(*str)) & 0xFF] ^ (crc >> 8);
            ++str;
        }
        return ~crc;
    }

    uint32 StrCrc32(const WIDECHAR* str)
    {
        if (str == nullptr)
        {
            return 0;
        }

        uint32 crc = ~0U;
        while (*str)
        {
            // ワイド文字は2バイトずつ処理
            uint8 lo = static_cast<uint8>(*str & 0xFF);
            uint8 hi = static_cast<uint8>((*str >> 8) & 0xFF);
            crc = s_crc32Table[(crc ^ lo) & 0xFF] ^ (crc >> 8);
            crc = s_crc32Table[(crc ^ hi) & 0xFF] ^ (crc >> 8);
            ++str;
        }
        return ~crc;
    }

    uint32 StrCrc32NoCase(const ANSICHAR* str)
    {
        if (str == nullptr)
        {
            return 0;
        }

        uint32 crc = ~0U;
        while (*str)
        {
            uint8 c = static_cast<uint8>(CharAnsi::ToLower(*str));
            crc = s_crc32Table[(crc ^ c) & 0xFF] ^ (crc >> 8);
            ++str;
        }
        return ~crc;
    }

    uint32 StrCrc32NoCase(const WIDECHAR* str)
    {
        if (str == nullptr)
        {
            return 0;
        }

        uint32 crc = ~0U;
        while (*str)
        {
            WIDECHAR lower = CharWide::ToLower(*str);
            uint8 lo = static_cast<uint8>(lower & 0xFF);
            uint8 hi = static_cast<uint8>((lower >> 8) & 0xFF);
            crc = s_crc32Table[(crc ^ lo) & 0xFF] ^ (crc >> 8);
            crc = s_crc32Table[(crc ^ hi) & 0xFF] ^ (crc >> 8);
            ++str;
        }
        return ~crc;
    }
}
```

## 検証

- 同一入力で同一CRC32値
- `StrCrc32("hello")` が決定論的
- `StrCrc32NoCase("HELLO")` == `StrCrc32NoCase("hello")`
- 空文字列のCRC32が0

## 注意事項

- CRC32テーブルは256エントリ（1KB）
- IEEE 802.3多項式（Ethernet CRC）を使用
- SSE4.2の `_mm_crc32_u8` 等で高速化可能（将来の最適化）

## 備考

これでPart 10の細分化が完了です。HAL実装計画全体の細分化が完了しました。
