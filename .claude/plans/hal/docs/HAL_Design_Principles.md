# Unreal Engine 5.7 HAL 設計原則 完全解説

## Hardware Abstraction Layer 設計思想とパターン

---

## 目次

1. [設計哲学](#1-設計哲学)
2. [3層抽象化アーキテクチャ](#2-3層抽象化アーキテクチャ)
3. [プラットフォーム切り替えパターン](#3-プラットフォーム切り替えパターン)
4. [コンパイル時 vs ランタイム抽象化](#4-コンパイル時-vs-ランタイム抽象化)
5. [インターフェース設計パターン](#5-インターフェース設計パターン)
6. [メモリ管理抽象化原則](#6-メモリ管理抽象化原則)
7. [スレッド抽象化設計](#7-スレッド抽象化設計)
8. [ファイルI/O抽象化パターン](#8-ファイルio抽象化パターン)
9. [エラーハンドリング戦略](#9-エラーハンドリング戦略)
10. [パフォーマンス最適化原則](#10-パフォーマンス最適化原則)
11. [後方互換性と非推奨化](#11-後方互換性と非推奨化)
12. [設計原則まとめ](#12-設計原則まとめ)

---

## 1. 設計哲学

### 1.1 基本理念

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      HAL 設計の基本理念                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  「一度書いて、どこでも動く」を実現しつつ、                            │
│  プラットフォーム固有の最適化を可能にする                              │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │                                                                   │ │
│  │  1. 統一された API                                                │ │
│  │     → エンジンコードは単一のインターフェースを使用                │ │
│  │                                                                   │ │
│  │  2. プラットフォーム透過性                                        │ │
│  │     → 呼び出し側はプラットフォームを意識しない                    │ │
│  │                                                                   │ │
│  │  3. 最適化の余地                                                  │ │
│  │     → 各プラットフォームは最適な実装を提供可能                    │ │
│  │                                                                   │ │
│  │  4. 段階的フォールバック                                          │ │
│  │     → 未実装機能は汎用実装にフォールバック                        │ │
│  │                                                                   │ │
│  │  5. コンパイル時決定優先                                          │ │
│  │     → 可能な限りコンパイル時に分岐を解決                          │ │
│  │                                                                   │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 設計目標

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        設計目標の優先順位                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  優先度 1: パフォーマンス                                              │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  • ゼロコスト抽象化を目指す                                       │ │
│  │  • インライン展開可能な設計                                       │ │
│  │  • 仮想関数呼び出しの最小化                                       │ │
│  │  • キャッシュフレンドリーなデータ構造                             │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  優先度 2: 移植性                                                      │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  • 新プラットフォーム追加の容易さ                                 │ │
│  │  • 汎用実装による即時動作保証                                     │ │
│  │  • プラットフォーム固有コードの分離                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  優先度 3: 保守性                                                      │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  • 明確な責務分離                                                 │ │
│  │  • 一貫した命名規則                                               │ │
│  │  • ドキュメント化された契約                                       │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  優先度 4: 拡張性                                                      │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  • 新機能追加時の既存コードへの影響最小化                         │ │
│  │  • 後方互換性の維持                                               │ │
│  │  • 段階的な非推奨化プロセス                                       │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 3層抽象化アーキテクチャ

### 2.1 レイヤー構造

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      3層抽象化アーキテクチャ                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    エンジンコード層                              │   │
│  │           (FPlatformMemory, FPlatformTime, etc.)                │   │
│  │                                                                  │   │
│  │  • プラットフォームを意識しない                                  │   │
│  │  • 統一された API を使用                                         │   │
│  │  • typedef によるプラットフォーム型へのエイリアス                │   │
│  └──────────────────────────┬──────────────────────────────────────┘   │
│                             │                                           │
│                             ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                  プラットフォーム固有層                          │   │
│  │       (FWindowsPlatformMemory, FUnixPlatformMemory, etc.)       │   │
│  │                                                                  │   │
│  │  • プラットフォーム固有の最適化                                  │   │
│  │  • 汎用実装のオーバーライド                                      │   │
│  │  • ネイティブ API の直接使用                                     │   │
│  └──────────────────────────┬──────────────────────────────────────┘   │
│                             │                                           │
│                             ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      汎用実装層                                  │   │
│  │              (FGenericPlatformMemory, etc.)                     │   │
│  │                                                                  │   │
│  │  • すべてのプラットフォームで動作する基本実装                    │   │
│  │  • フォールバックとして機能                                      │   │
│  │  • 共通ロジックの集約                                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 継承パターン

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        継承パターン例                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【型システムの継承】                                                   │
│                                                                         │
│  FGenericPlatformTypes (基底)                                          │
│        ↑                                                                │
│  FWindowsPlatformTypes : public FGenericPlatformTypes                  │
│        ↑                                                                │
│  typedef FWindowsPlatformTypes FPlatformTypes (エイリアス)             │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 汎用基底クラス                                                │ │
│  │  struct FGenericPlatformTypes                                     │ │
│  │  {                                                                │ │
│  │      typedef unsigned char      uint8;                            │ │
│  │      typedef unsigned short     uint16;                           │ │
│  │      typedef unsigned int       uint32;                           │ │
│  │      typedef unsigned long long uint64;                           │ │
│  │      // ... 共通型定義                                            │ │
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // プラットフォーム固有の拡張                                    │ │
│  │  struct FWindowsPlatformTypes : public FGenericPlatformTypes      │ │
│  │  {                                                                │ │
│  │      #ifdef _WIN64                                                │ │
│  │          typedef unsigned __int64 SIZE_T;                         │ │
│  │          typedef __int64 SSIZE_T;                                 │ │
│  │      #else                                                        │ │
│  │          typedef unsigned long SIZE_T;                            │ │
│  │          typedef long SSIZE_T;                                    │ │
│  │      #endif                                                       │ │
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // エンジンが使用するエイリアス                                  │ │
│  │  typedef FWindowsPlatformTypes FPlatformTypes;                    │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 フォールバックメカニズム

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     フォールバックメカニズム                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【原則】                                                               │
│  プラットフォーム固有実装が未定義の場合、                              │
│  汎用実装が自動的に使用される                                          │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │                                                                   │ │
│  │  // 汎用実装 (常に動作する基本実装)                               │ │
│  │  class FGenericPlatformMemory                                     │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      static void Init();                                          │ │
│  │      static FPlatformMemoryStats GetStats();                      │ │
│  │      static void OnOutOfMemory(uint64 Size, uint32 Alignment);    │ │
│  │      // ... 汎用実装                                              │ │
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // Windows 固有実装 (最適化版)                                   │ │
│  │  class FWindowsPlatformMemory : public FGenericPlatformMemory     │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      static void Init()                                           │ │
│  │      {                                                            │ │
│  │          FGenericPlatformMemory::Init();  // 基底を呼び出し       │ │
│  │          // Windows 固有の追加処理                                │ │
│  │      }                                                            │ │
│  │      // GetStats() をオーバーライドして最適化                     │ │
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // エンジンが使用するエイリアス                                  │ │
│  │  typedef FWindowsPlatformMemory FPlatformMemory;                  │ │
│  │                                                                   │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. プラットフォーム切り替えパターン

### 3.1 マクロベースのプラットフォーム検出

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   マクロベースのプラットフォーム検出                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【基本プラットフォームマクロ】                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  #if !defined(PLATFORM_WINDOWS)                                   │ │
│  │      #define PLATFORM_WINDOWS 0                                   │ │
│  │  #endif                                                           │ │
│  │  #if !defined(PLATFORM_MAC)                                       │ │
│  │      #define PLATFORM_MAC 0                                       │ │
│  │  #endif                                                           │ │
│  │  #if !defined(PLATFORM_IOS)                                       │ │
│  │      #define PLATFORM_IOS 0                                       │ │
│  │  #endif                                                           │ │
│  │  #if !defined(PLATFORM_ANDROID)                                   │ │
│  │      #define PLATFORM_ANDROID 0                                   │ │
│  │  #endif                                                           │ │
│  │  #if !defined(PLATFORM_LINUX)                                     │ │
│  │      #define PLATFORM_LINUX 0                                     │ │
│  │  #endif                                                           │ │
│  │  #if !defined(PLATFORM_UNIX)                                      │ │
│  │      #define PLATFORM_UNIX 0                                      │ │
│  │  #endif                                                           │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【使用パターン】                                                       │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 排他的なプラットフォーム分岐                                  │ │
│  │  #if PLATFORM_WINDOWS                                             │ │
│  │      // Windows 固有コード                                        │ │
│  │  #elif PLATFORM_MAC                                               │ │
│  │      // macOS 固有コード                                          │ │
│  │  #elif PLATFORM_LINUX                                             │ │
│  │      // Linux 固有コード                                          │ │
│  │  #else                                                            │ │
│  │      // 汎用フォールバック                                        │ │
│  │  #endif                                                           │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 機能検出マクロ

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       機能検出マクロパターン                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【HAS_* / PLATFORM_HAS_* パターン】                                    │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 機能の存在を示すマクロ                                        │ │
│  │  #define PLATFORM_HAS_BSD_TIME                1                   │ │
│  │  #define PLATFORM_HAS_BSD_THREAD_CPUTIME      0                   │ │
│  │  #define PLATFORM_HAS_BSD_SOCKETS             1                   │ │
│  │  #define PLATFORM_HAS_128BIT_ATOMICS          (PLATFORM_64BITS)   │ │
│  │  #define PLATFORM_HAS_TOUCH_MAIN_SCREEN       0                   │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【PLATFORM_SUPPORTS_* パターン】                                       │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 機能サポートを示すマクロ                                      │ │
│  │  #define PLATFORM_SUPPORTS_ASYMMETRIC_FENCES  1                   │ │
│  │  #define PLATFORM_SUPPORTS_VIRTUAL_TEXTURE    1                   │ │
│  │  #define PLATFORM_SUPPORTS_GEOMETRY_SHADERS   1                   │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【PLATFORM_USE_* パターン】                                            │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 使用する実装を示すマクロ                                      │ │
│  │  #define PLATFORM_USE_PTHREADS                1                   │ │
│  │  #define PLATFORM_USES_MICROSOFT_LIBC_FUNCTIONS  1                │ │
│  │  #define PLATFORM_USE_ANSI_POSIX_MALLOC       0                   │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.3 COMPILED_PLATFORM_HEADER パターン

```
┌─────────────────────────────────────────────────────────────────────────┐
│                  COMPILED_PLATFORM_HEADER パターン                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【定義】                                                               │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  #define COMPILED_PLATFORM_HEADER(Suffix) \                       │ │
│  │      PREPROCESSOR_TO_STRING(PREPROCESSOR_JOIN(                    │ │
│  │          PLATFORM_HEADER_NAME/PLATFORM_HEADER_NAME, Suffix))      │ │
│  │                                                                   │ │
│  │  // PLATFORM_HEADER_NAME は各プラットフォームで定義:              │ │
│  │  // Windows → "Windows"                                           │ │
│  │  // Linux   → "Linux"                                             │ │
│  │  // Mac     → "Mac"                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【使用例】                                                             │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  #include COMPILED_PLATFORM_HEADER(PlatformFile.h)                │ │
│  │                                                                   │ │
│  │  // 展開結果:                                                     │ │
│  │  // Windows: "Windows/WindowsPlatformFile.h"                      │ │
│  │  // Linux:   "Linux/LinuxPlatformFile.h"                          │ │
│  │  // Mac:     "Mac/MacPlatformFile.h"                              │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【利点】                                                               │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  • 単一の include 文で全プラットフォーム対応                      │ │
│  │  • コンパイル時に適切なヘッダーが選択される                       │ │
│  │  • 新プラットフォーム追加時も呼び出し側の変更不要                 │ │
│  │  • 命名規則の強制による一貫性                                     │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.4 CPU アーキテクチャ検出

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    CPU アーキテクチャ検出                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【アーキテクチャファミリー】                                           │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  #define PLATFORM_CPU_X86_FAMILY    1  // x86/x64                 │ │
│  │  #define PLATFORM_CPU_ARM_FAMILY    0  // ARM/ARM64               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【SIMD 命令セット検出】                                                │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // コンパイル時に常に利用可能                                    │ │
│  │  #define PLATFORM_ALWAYS_HAS_SSE4_1  PLATFORM_CPU_X86_FAMILY      │ │
│  │  #define PLATFORM_ALWAYS_HAS_SSE4_2  PLATFORM_CPU_X86_FAMILY      │ │
│  │                                                                   │ │
│  │  // 実行時検出が必要                                              │ │
│  │  #define PLATFORM_MAYBE_HAS_AVX      0                            │ │
│  │  #define PLATFORM_ALWAYS_HAS_AVX_2   0                            │ │
│  │                                                                   │ │
│  │  // ARM NEON                                                      │ │
│  │  #define PLATFORM_ENABLE_VECTORINTRINSICS_NEON  0                 │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【ビット幅】                                                           │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  #define PLATFORM_32BITS  0                                       │ │
│  │  #define PLATFORM_64BITS  1                                       │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. コンパイル時 vs ランタイム抽象化

### 4.1 決定基準

```
┌─────────────────────────────────────────────────────────────────────────┐
│                コンパイル時 vs ランタイム 決定基準                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【コンパイル時決定を選ぶ場合】                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  ✓ ハードウェア能力が固定 (SSE4.2, AVX, NEON)                     │ │
│  │  ✓ OS API の違い (POSIX vs Win32)                                 │ │
│  │  ✓ 型サイズの違い (32bit vs 64bit)                                │ │
│  │  ✓ ホットパスで呼ばれる関数                                       │ │
│  │  ✓ インライン展開が重要な場合                                     │ │
│  │  ✓ バイナリサイズを最小化したい場合                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【ランタイム決定を選ぶ場合】                                           │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  ✓ プラグイン/拡張による差し替え                                  │ │
│  │  ✓ 設定ファイルによる切り替え                                     │ │
│  │  ✓ テスト/モック注入                                              │ │
│  │  ✓ デコレータパターン (ラッパーチェーン)                          │ │
│  │  ✓ 動的ロードされるモジュール                                     │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 コンパイル時抽象化の例

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    コンパイル時抽象化の例                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【アトミック操作】                                                     │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // プラットフォーム固有の実装が直接インライン展開される          │ │
│  │  static FORCEINLINE int32 InterlockedIncrement(volatile int32* V) │ │
│  │  {                                                                │ │
│  │  #if PLATFORM_WINDOWS                                             │ │
│  │      return (int32)_InterlockedIncrement((long*)V);               │ │
│  │  #elif PLATFORM_USE_PTHREADS                                      │ │
│  │      return __sync_add_and_fetch(V, 1);                           │ │
│  │  #endif                                                           │ │
│  │  }                                                                │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【メモリアロケータ選択】                                               │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // コンパイル時にアロケータの型が決定                            │ │
│  │  enum EMemoryAllocatorToUse                                       │ │
│  │  {                                                                │ │
│  │      Ansi, Stomp, TBB, Jemalloc,                                  │ │
│  │      Binned, Binned2, Binned3,                                    │ │
│  │      Platform, Mimalloc, Libpas                                   │ │
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // プラットフォームごとにデフォルトが異なる                      │ │
│  │  #if PLATFORM_WINDOWS                                             │ │
│  │      static EMemoryAllocatorToUse AllocatorToUse = Binned3;       │ │
│  │  #elif PLATFORM_MAC                                               │ │
│  │      static EMemoryAllocatorToUse AllocatorToUse = Mimalloc;      │ │
│  │  #endif                                                           │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【文字列エンコーディング】                                             │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // TCHAR のサイズがコンパイル時に決定                            │ │
│  │  #if USE_UTF8_TCHARS                                              │ │
│  │      typedef UTF8CHAR TCHAR;                                      │ │
│  │  #else                                                            │ │
│  │      typedef WIDECHAR TCHAR;                                      │ │
│  │  #endif                                                           │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.3 ランタイム抽象化の例

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    ランタイム抽象化の例                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【ファイルシステムラッパーチェーン】                                   │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  class IPlatformFile                                              │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      virtual bool Initialize(IPlatformFile* Inner, ...) = 0;     │ │
│  │      virtual IPlatformFile* GetLowerLevel() = 0;                  │ │
│  │      virtual void SetLowerLevel(IPlatformFile* NewLower) = 0;     │ │
│  │      virtual IFileHandle* OpenRead(...) = 0;                      │ │
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // デコレータパターンでラッパーを積み重ね                        │ │
│  │  //                                                               │ │
│  │  //  アプリケーション                                             │ │
│  │  //       ↓                                                       │ │
│  │  //  IPlatformFileCachedWrapper (キャッシュ層)                    │ │
│  │  //       ↓                                                       │ │
│  │  //  IPlatformFileLogWrapper (ログ層)                             │ │
│  │  //       ↓                                                       │ │
│  │  //  FPhysicalPlatformFile (実ファイルシステム)                   │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【メモリアロケータのランタイム選択】                                   │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  class FMalloc : public FUseSystemMallocForNew, public FExec      │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      // 仮想関数による動的ディスパッチ                            │ │
│  │      virtual void* Malloc(SIZE_T Size, uint32 Align) = 0;         │ │
│  │      virtual void* Realloc(void* Ptr, SIZE_T NewSize, ...) = 0;   │ │
│  │      virtual void Free(void* Ptr) = 0;                            │ │
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // コマンドライン引数でランタイム選択可能                        │ │
│  │  // -ansimalloc, -tbbmalloc, -jemalloc, etc.                      │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.4 ハイブリッドアプローチ

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     ハイブリッドアプローチ                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【原則】                                                               │
│  コンパイル時に決定できる部分は固定し、                                │
│  拡張が必要な部分のみ仮想関数を使用                                    │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  class FMalloc                                                    │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      // 仮想関数 (ランタイムディスパッチ必要)                      │ │
│  │      virtual void* Malloc(SIZE_T Size, uint32 Align) = 0;         │ │
│  │      virtual void Free(void* Ptr) = 0;                            │ │
│  │                                                                   │ │
│  │      // 非仮想関数 (インライン展開可能)                           │ │
│  │      void* TryMalloc(SIZE_T Size, uint32 Align)                   │ │
│  │      {                                                            │ │
│  │          // デフォルト実装を提供                                  │ │
│  │          return Malloc(Size, Align);                              │ │
│  │      }                                                            │ │
│  │                                                                   │ │
│  │      // コンパイル時定数                                          │ │
│  │      static constexpr uint32 DEFAULT_ALIGNMENT = 16;              │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 5. インターフェース設計パターン

### 5.1 純粋仮想インターフェース

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    純粋仮想インターフェースパターン                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【ファイルハンドルインターフェース】                                   │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  class IFileHandle                                                │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      virtual ~IFileHandle() {}                                    │ │
│  │                                                                   │ │
│  │      // 位置操作 (必須)                                           │ │
│  │      virtual int64 Tell() = 0;                                    │ │
│  │      virtual bool Seek(int64 NewPosition) = 0;                    │ │
│  │      virtual bool SeekFromEnd(int64 RelativePosition = 0) = 0;    │ │
│  │                                                                   │ │
│  │      // 読み書き (必須)                                           │ │
│  │      virtual bool Read(uint8* Dst, int64 BytesToRead) = 0;        │ │
│  │      virtual bool Write(const uint8* Src, int64 BytesToWrite) = 0;│ │
│  │                                                                   │ │
│  │      // 追加機能 (オプション、デフォルト実装あり)                 │ │
│  │      virtual bool ReadAt(uint8* Dst, int64 Bytes, int64 Offset)   │ │
│  │      {                                                            │ │
│  │          return Seek(Offset) && Read(Dst, Bytes);                 │ │
│  │      }                                                            │ │
│  │                                                                   │ │
│  │      virtual bool Flush(bool bFullFlush = false) = 0;             │ │
│  │      virtual bool Truncate(int64 NewSize) = 0;                    │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【利点】                                                               │
│  • 契約の明確化 (純粋仮想 = 必須実装)                                  │
│  • テスト用モック作成が容易                                            │
│  • 実装の差し替えが容易                                                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 RAII パターン

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         RAII パターン                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【リソース管理の原則】                                                 │
│  • コンストラクタでリソース獲得                                        │
│  • デストラクタでリソース解放                                          │
│  • コピー禁止またはコピーセマンティクスの明示                          │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // イベント参照 (コピー禁止、ムーブ禁止)                         │ │
│  │  class FEventRef final                                            │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      // コンストラクタでイベント獲得                              │ │
│  │      explicit FEventRef(EEventMode Mode = EEventMode::AutoReset); │ │
│  │                                                                   │ │
│  │      // デストラクタでイベント返却                                │ │
│  │      ~FEventRef();                                                │ │
│  │                                                                   │ │
│  │      // コピー/ムーブ禁止 (リソースの共有を防ぐ)                  │ │
│  │      FEventRef(const FEventRef&) = delete;                        │ │
│  │      FEventRef& operator=(const FEventRef&) = delete;             │ │
│  │      FEventRef(FEventRef&&) = delete;                             │ │
│  │      FEventRef& operator=(FEventRef&&) = delete;                  │ │
│  │                                                                   │ │
│  │  private:                                                         │ │
│  │      FEvent* Event;  // プールから借りたイベント                  │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // スコープロック (コピー禁止、ムーブ可能)                       │ │
│  │  template<typename MutexType>                                     │ │
│  │  class TScopeLock                                                 │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      explicit TScopeLock(MutexType& InMutex)                      │ │
│  │          : Mutex(&InMutex)                                        │ │
│  │      {                                                            │ │
│  │          Mutex->Lock();                                           │ │
│  │      }                                                            │ │
│  │                                                                   │ │
│  │      ~TScopeLock()                                                │ │
│  │      {                                                            │ │
│  │          if (Mutex)                                               │ │
│  │              Mutex->Unlock();                                     │ │
│  │      }                                                            │ │
│  │                                                                   │ │
│  │      // コピー禁止                                                │ │
│  │      TScopeLock(const TScopeLock&) = delete;                      │ │
│  │      TScopeLock& operator=(const TScopeLock&) = delete;           │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.3 インライン最適化パターン

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    インライン最適化パターン                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【UE_REWRITE マクロ】                                                  │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // シンボル生成なし、常にインライン展開                          │ │
│  │  #define UE_REWRITE UE_NODEBUG FORCEINLINE                        │ │
│  │                                                                   │ │
│  │  // 単純な転送関数に使用                                          │ │
│  │  class FPlatformRWLock final                                      │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      UE_REWRITE bool TryWriteLock() { return Mutex.TryLock(); }   │ │
│  │      UE_REWRITE void WriteLock()    { Mutex.Lock(); }             │ │
│  │      UE_REWRITE void WriteUnlock()  { Mutex.Unlock(); }           │ │
│  │      UE_REWRITE bool TryReadLock()  { return Mutex.TryLockShared(); }│
│  │      UE_REWRITE void ReadLock()     { Mutex.LockShared(); }       │ │
│  │      UE_REWRITE void ReadUnlock()   { Mutex.UnlockShared(); }     │ │
│  │  private:                                                         │ │
│  │      FPlatformSharedMutex Mutex;                                  │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【FORCEINLINE の使用基準】                                             │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  ✓ ホットパスの小さな関数                                         │ │
│  │  ✓ アトミック操作のラッパー                                       │ │
│  │  ✓ ゲッター/セッター                                              │ │
│  │  ✓ 型変換関数                                                     │ │
│  │                                                                   │ │
│  │  ✗ 大きな関数 (コードサイズ増大)                                  │ │
│  │  ✗ 再帰関数                                                       │ │
│  │  ✗ 仮想関数                                                       │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 6. メモリ管理抽象化原則

### 6.1 メモリ統計構造

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      メモリ統計構造                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【定数構造体】                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  struct FGenericPlatformMemoryConstants                           │ │
│  │  {                                                                │ │
│  │      uint64 TotalPhysical = 0;           // 物理メモリ総量        │ │
│  │      uint64 TotalVirtual = 0;            // 仮想メモリ総量        │ │
│  │      SIZE_T PageSize = 0;                // ページサイズ          │ │
│  │      SIZE_T OsAllocationGranularity = 0; // OS 割り当て粒度       │ │
│  │      SIZE_T BinnedPageSize = 0;          // Binned ページサイズ   │ │
│  │      SIZE_T BinnedAllocationGranularity = 0; // Binned 粒度       │ │
│  │      uint64 AddressStart = 0;            // アドレス空間開始      │ │
│  │      uint64 AddressLimit = 0xffffffff+1; // アドレス空間上限      │ │
│  │      uint32 TotalPhysicalGB = 1;         // 物理メモリ (GB)       │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【統計構造体】                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  struct FGenericPlatformMemoryStats : FPlatformMemoryConstants    │ │
│  │  {                                                                │ │
│  │      uint64 AvailablePhysical;   // 利用可能物理メモリ            │ │
│  │      uint64 AvailableVirtual;    // 利用可能仮想メモリ            │ │
│  │      uint64 UsedPhysical;        // 使用中物理メモリ              │ │
│  │      uint64 PeakUsedPhysical;    // 最大使用物理メモリ            │ │
│  │      uint64 UsedVirtual;         // 使用中仮想メモリ              │ │
│  │      uint64 PeakUsedVirtual;     // 最大使用仮想メモリ            │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.2 アロケータ選択パターン

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    アロケータ選択パターン                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【選択可能なアロケータ】                                               │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  enum EMemoryAllocatorToUse                                       │ │
│  │  {                                                                │ │
│  │      Ansi,      // 標準 C ライブラリ                              │ │
│  │      Stomp,     // デバッグ用 (アクセス違反検出)                  │ │
│  │      TBB,       // Intel Threading Building Blocks                │ │
│  │      Jemalloc,  // jemalloc                                       │ │
│  │      Binned,    // UE 独自 (旧)                                   │ │
│  │      Binned2,   // UE 独自 (中)                                   │ │
│  │      Binned3,   // UE 独自 (新) ← 推奨                            │ │
│  │      Platform,  // プラットフォーム固有                           │ │
│  │      Mimalloc,  // Microsoft mimalloc                             │ │
│  │      Libpas,    // Apple libpas                                   │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【選択メカニズム】                                                     │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // コマンドライン引数で選択                                      │ │
│  │  -ansimalloc                                                      │ │
│  │  -tbbmalloc                                                       │ │
│  │  -jemalloc                                                        │ │
│  │  -binnedmalloc / -binnedmalloc2 / -binnedmalloc3                  │ │
│  │  -mimalloc                                                        │ │
│  │  -stompmalloc                                                     │ │
│  │                                                                   │ │
│  │  // BaseAllocator() で適切なインスタンスを返す                    │ │
│  │  static FMalloc* BaseAllocator();                                 │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.3 OOM ハンドリング

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      OOM ハンドリング戦略                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【メモリ圧力状態】                                                     │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  enum class EMemoryPressureStatus : uint8                         │ │
│  │  {                                                                │ │
│  │      Unknown,   // 不明                                           │ │
│  │      Nominal,   // 正常                                           │ │
│  │      Warning,   // 警告 (メモリ不足の兆候)                        │ │
│  │      Critical,  // 危険 (OOM のリスク高)                          │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【バックアップメモリプール】                                           │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // OOM 時のクラッシュレポート用予備メモリ                        │ │
│  │  static void* BackupOOMMemoryPool;                                │ │
│  │  static uint32 BackupOOMMemoryPoolSize;                           │ │
│  │                                                                   │ │
│  │  // OOM 状態フラグ                                                │ │
│  │  static bool bIsOOM;                                              │ │
│  │  static uint64 OOMAllocationSize;                                 │ │
│  │  static uint32 OOMAllocationAlignment;                            │ │
│  │                                                                   │ │
│  │  // OOM ハンドラ (戻らない)                                       │ │
│  │  [[noreturn]] static void OnOutOfMemory(uint64 Size, uint32 Align);│
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 7. スレッド抽象化設計

### 7.1 イベントインターフェース

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    イベントインターフェース                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【基底クラス】                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  class FEvent                                                     │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      // 作成 (非推奨 - プールを使用すること)                      │ │
│  │      virtual bool Create(bool bIsManualReset = false) = 0;        │ │
│  │                                                                   │ │
│  │      // 状態照会                                                  │ │
│  │      virtual bool IsManualReset() = 0;                            │ │
│  │                                                                   │ │
│  │      // シグナル操作                                              │ │
│  │      virtual void Trigger() = 0;   // シグナル状態にする          │ │
│  │      virtual void Reset() = 0;     // 非シグナル状態にする        │ │
│  │                                                                   │ │
│  │      // 待機                                                      │ │
│  │      virtual bool Wait(uint32 WaitTime,                           │ │
│  │                        bool bIgnoreThreadIdleStats = false) = 0;  │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【モード】                                                             │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  enum class EEventMode                                            │ │
│  │  {                                                                │ │
│  │      AutoReset,    // Wait 成功後に自動リセット                   │ │
│  │      ManualReset,  // 明示的な Reset() 呼び出しが必要             │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 7.2 ミューテックステンプレートパターン

```
┌─────────────────────────────────────────────────────────────────────────┐
│                  ミューテックステンプレートパターン                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【汎用共有ミューテックス】                                             │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  template <class MutexType>                                       │ │
│  │  class TGenericPlatformSharedMutex                                │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      // 排他ロック                                                │ │
│  │      UE_FORCEINLINE bool TryLock() { return Mutex.TryLock(); }    │ │
│  │      UE_FORCEINLINE void Lock()    { Mutex.Lock(); }              │ │
│  │      UE_FORCEINLINE void Unlock()  { Mutex.Unlock(); }            │ │
│  │                                                                   │ │
│  │      // 共有ロック (汎用実装では排他ロックと同等)                 │ │
│  │      UE_FORCEINLINE bool TryLockShared() { return TryLock(); }    │ │
│  │      UE_FORCEINLINE void LockShared()    { Lock(); }              │ │
│  │      UE_FORCEINLINE void UnlockShared()  { Unlock(); }            │ │
│  │                                                                   │ │
│  │  private:                                                         │ │
│  │      MutexType Mutex;                                             │ │
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // プラットフォーム固有実装は共有ロックを最適化可能              │ │
│  │  // (pthread_rwlock, SRWLOCK など)                                │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【型エイリアス】                                                       │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  using FCriticalSection = UE::FPlatformRecursiveMutex;            │ │
│  │  using FRWLock = UE::FPlatformRWLock;                             │ │
│  │  using FSystemWideCriticalSection = UE::FPlatformSystemWideMutex; │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 8. ファイルI/O抽象化パターン

### 8.1 レイヤードアーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────────┐
│                 ファイルI/O レイヤードアーキテクチャ                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    アプリケーション層                            │   │
│  │                  (FFileHelper, IFileManager)                     │   │
│  └──────────────────────────┬──────────────────────────────────────┘   │
│                             │                                           │
│                             ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                   ラッパー層 (オプション)                        │   │
│  │                                                                  │   │
│  │  IPlatformFileCachedWrapper     ← キャッシュ                    │   │
│  │  IPlatformFileLogWrapper        ← ログ記録                      │   │
│  │  IPlatformFileOpenLogWrapper    ← オープンログ                  │   │
│  │  IPlatformFileManagedStorageWrapper ← 管理ストレージ            │   │
│  └──────────────────────────┬──────────────────────────────────────┘   │
│                             │                                           │
│                             ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                   プラットフォーム層                             │   │
│  │                   (IPlatformFile 実装)                           │   │
│  │                                                                  │   │
│  │  FWindowsPlatformFile, FUnixPlatformFile, etc.                   │   │
│  └──────────────────────────┬──────────────────────────────────────┘   │
│                             │                                           │
│                             ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      OS 層                                       │   │
│  │                  (Win32 API, POSIX, etc.)                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 8.2 デコレータパターン

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      デコレータパターン                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【基底インターフェース】                                               │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  class IPlatformFile                                              │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      // 下位層への接続                                            │ │
│  │      virtual bool Initialize(IPlatformFile* Inner, ...) = 0;     │ │
│  │      virtual IPlatformFile* GetLowerLevel() = 0;                  │ │
│  │      virtual void SetLowerLevel(IPlatformFile* NewLower) = 0;     │ │
│  │                                                                   │ │
│  │      // 識別                                                      │ │
│  │      virtual const TCHAR* GetName() const = 0;                    │ │
│  │                                                                   │ │
│  │      // ファイル操作                                              │ │
│  │      virtual IFileHandle* OpenRead(...) = 0;                      │ │
│  │      virtual IFileHandle* OpenWrite(...) = 0;                     │ │
│  │      // ...                                                       │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【ラッパー実装例】                                                     │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  class FLoggedPlatformFile : public IPlatformFile                 │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      virtual IFileHandle* OpenRead(const TCHAR* Filename, ...)    │ │
│  │      {                                                            │ │
│  │          // ログ記録                                              │ │
│  │          UE_LOG(LogPlatformFile, Log, TEXT("OpenRead: %s"), ...); │ │
│  │                                                                   │ │
│  │          // 下位層に委譲                                          │ │
│  │          return LowerLevel->OpenRead(Filename, ...);              │ │
│  │      }                                                            │ │
│  │                                                                   │ │
│  │  private:                                                         │ │
│  │      IPlatformFile* LowerLevel;                                   │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 9. エラーハンドリング戦略

### 9.1 Result 型パターン

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Result 型パターン                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【TValueOrError テンプレート】                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 成功時は値、失敗時はエラーを保持                              │ │
│  │  template<typename ValueType, typename ErrorType>                 │ │
│  │  class TValueOrError;                                             │ │
│  │                                                                   │ │
│  │  // ファイルオープン結果の型定義                                  │ │
│  │  using FFileOpenResult = TValueOrError<                           │ │
│  │      TUniquePtr<IFileHandle>,                                     │ │
│  │      FFileSystemError                                             │ │
│  │  >;                                                               │ │
│  │                                                                   │ │
│  │  using FFileOpenAsyncResult = TValueOrError<                      │ │
│  │      TUniquePtr<IAsyncReadFileHandle>,                            │ │
│  │      FFileSystemError                                             │ │
│  │  >;                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【エラー構造体】                                                       │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  class FFileSystemError                                           │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      FFileSystemError(FString&& InMsg, int32 InSysCode = 0)       │ │
│  │          : ErrorMessage(MoveTemp(InMsg))                          │ │
│  │          , SystemErrorCode(InSysCode)                             │ │
│  │      {}                                                           │ │
│  │                                                                   │ │
│  │      FString GetMessage()                                         │ │
│  │      {                                                            │ │
│  │          if (SystemErrorCode != 0)                                │ │
│  │          {                                                        │ │
│  │              // プラットフォーム固有のエラーメッセージを取得      │ │
│  │              TCHAR SysMsg[MAX_SPRINTF];                           │ │
│  │              FPlatformMisc::GetSystemErrorMessage(                │ │
│  │                  SysMsg, UE_ARRAY_COUNT(SysMsg), SystemErrorCode);│ │
│  │              return FString::Printf(TEXT("%s [%s (%d)]"),         │ │
│  │                  *ErrorMessage, SysMsg, SystemErrorCode);         │ │
│  │          }                                                        │ │
│  │          return ErrorMessage;                                     │ │
│  │      }                                                            │ │
│  │                                                                   │ │
│  │  private:                                                         │ │
│  │      FString ErrorMessage;                                        │ │
│  │      int32 SystemErrorCode;                                       │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 9.2 プラットフォーム固有エラーコード

```
┌─────────────────────────────────────────────────────────────────────────┐
│                プラットフォーム固有エラーコード処理                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【原則】                                                               │
│  • システムエラーコードは保存して後から変換                            │
│  • 遅延評価でエラーメッセージを生成                                    │
│  • プラットフォーム固有の詳細を隠蔽                                    │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // プラットフォーム共通 API                                      │ │
│  │  class FPlatformMisc                                              │ │
│  │  {                                                                │ │
│  │  public:                                                          │ │
│  │      // システムエラーメッセージを取得                            │ │
│  │      static void GetSystemErrorMessage(                           │ │
│  │          TCHAR* OutBuffer,                                        │ │
│  │          int32 BufferSize,                                        │ │
│  │          int32 ErrorCode                                          │ │
│  │      );                                                           │ │
│  │                                                                   │ │
│  │      // 最後のシステムエラーを取得                                │ │
│  │      static uint32 GetLastError();                                │ │
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // Windows 実装例                                                │ │
│  │  void FWindowsPlatformMisc::GetSystemErrorMessage(...)            │ │
│  │  {                                                                │ │
│  │      FormatMessage(                                               │ │
│  │          FORMAT_MESSAGE_FROM_SYSTEM,                              │ │
│  │          NULL, ErrorCode, LANG_SYSTEM_DEFAULT,                    │ │
│  │          OutBuffer, BufferSize, NULL                              │ │
│  │      );                                                           │ │
│  │  }                                                                │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 10. パフォーマンス最適化原則

### 10.1 インライン展開

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       インライン展開戦略                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【マクロ定義】                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // プラットフォーム固有                                          │ │
│  │  #if _MSC_VER                                                     │ │
│  │      #define FORCEINLINE __forceinline                            │ │
│  │  #elif __GNUC__                                                   │ │
│  │      #define FORCEINLINE inline __attribute__((always_inline))    │ │
│  │  #else                                                            │ │
│  │      #define FORCEINLINE inline                                   │ │
│  │  #endif                                                           │ │
│  │                                                                   │ │
│  │  // デバッグ情報なし + 強制インライン                             │ │
│  │  #define UE_REWRITE UE_NODEBUG FORCEINLINE                        │ │
│  │                                                                   │ │
│  │  // インラインヒント (コンパイラ判断)                             │ │
│  │  #define UE_FORCEINLINE_HINT FORCEINLINE                          │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【使い分け基準】                                                       │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  FORCEINLINE:                                                     │ │
│  │    • アトミック操作ラッパー                                       │ │
│  │    • 単純なゲッター/セッター                                      │ │
│  │    • 型変換関数                                                   │ │
│  │    • ホットパスの小さな関数                                       │ │
│  │                                                                   │ │
│  │  UE_REWRITE:                                                      │ │
│  │    • API 互換性のための転送関数                                   │ │
│  │    • デバッグシンボル不要な単純ラッパー                           │ │
│  │                                                                   │ │
│  │  inline (通常):                                                   │ │
│  │    • やや大きな関数                                               │ │
│  │    • コンパイラに判断を委ねる場合                                 │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 10.2 キャッシュライン最適化

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     キャッシュライン最適化                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【キャッシュラインサイズ】                                             │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  #ifndef PLATFORM_CACHE_LINE_SIZE                                 │ │
│  │      #define PLATFORM_CACHE_LINE_SIZE 64  // Intel/AMD            │ │
│  │  #endif                                                           │ │
│  │                                                                   │ │
│  │  // Apple Silicon (M1/M2)                                         │ │
│  │  #if PLATFORM_MAC                                                 │ │
│  │      #undef PLATFORM_CACHE_LINE_SIZE                              │ │
│  │      #define PLATFORM_CACHE_LINE_SIZE 128                         │ │
│  │  #endif                                                           │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【偽共有の防止】                                                       │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 異なるスレッドからアクセスされるデータを分離                  │ │
│  │  struct alignas(PLATFORM_CACHE_LINE_SIZE) FThreadLocalCounter     │ │
│  │  {                                                                │ │
│  │      TAtomic<int64> Counter;                                      │ │
│  │      // パディングでキャッシュラインを埋める                      │ │
│  │      uint8 Padding[PLATFORM_CACHE_LINE_SIZE - sizeof(TAtomic<int64>)];│
│  │  };                                                               │ │
│  │                                                                   │ │
│  │  // より保守的なアプローチ (2キャッシュライン)                    │ │
│  │  struct alignas(PLATFORM_CACHE_LINE_SIZE * 2) FSuperAlignedData   │ │
│  │  {                                                                │ │
│  │      // ...                                                       │ │
│  │  };                                                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 10.3 コンパイラ最適化制御

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    コンパイラ最適化制御                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【最適化の無効化/有効化】                                              │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 最適化を一時的に無効化                                        │ │
│  │  #define PRAGMA_DISABLE_OPTIMIZATION_ACTUAL \                     │ │
│  │      __pragma(optimize("", off))                                  │ │
│  │                                                                   │ │
│  │  #define PRAGMA_ENABLE_OPTIMIZATION_ACTUAL \                      │ │
│  │      __pragma(optimize("", on))                                   │ │
│  │                                                                   │ │
│  │  // 使用例: デバッグしたい関数を囲む                              │ │
│  │  PRAGMA_DISABLE_OPTIMIZATION                                      │ │
│  │  void HardToDebugFunction()                                       │ │
│  │  {                                                                │ │
│  │      // この関数は最適化されない                                  │ │
│  │  }                                                                │ │
│  │  PRAGMA_ENABLE_OPTIMIZATION                                       │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【ビルド構成別の最適化】                                               │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // シッピングビルドでのみ最適化を無効化                          │ │
│  │  #define BEGIN_FUNCTION_BUILD_OPTIMIZATION \                      │ │
│  │      UE_DISABLE_OPTIMIZATION_SHIP                                 │ │
│  │  #define END_FUNCTION_BUILD_OPTIMIZATION \                        │ │
│  │      UE_ENABLE_OPTIMIZATION_SHIP                                  │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 11. 後方互換性と非推奨化

### 11.1 非推奨化パターン

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       非推奨化パターン                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【UE_DEPRECATED マクロ】                                               │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 関数/クラスの非推奨化                                         │ │
│  │  UE_DEPRECATED(5.0, "メッセージ")                                 │ │
│  │  virtual bool Create(bool bIsManualReset = false) = 0;            │ │
│  │                                                                   │ │
│  │  // 型の非推奨化                                                  │ │
│  │  [[deprecated("CHAR32 は非推奨 - UTF32CHAR を使用")]]             │ │
│  │  typedef uint32 CHAR32;                                           │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【UE_DEPRECATED_MACRO マクロ】                                         │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // マクロの非推奨化                                              │ │
│  │  #define PLATFORM_COMPILER_SUPPORTS_CONSTEXPR_BUILTIN_FILE_AND_LINE 1 \│
│  │      UE_DEPRECATED_MACRO(5.7, "非推奨です。1 に置き換えてください。")│
│  │                                                                   │ │
│  │  #define UE_UTF8TEXT_IS_CONSTEXPR 1 \                             │ │
│  │      UE_DEPRECATED_MACRO(5.7, "非推奨です。")                     │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【コンパイルエラーを強制するパターン】                                 │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 使用すると即座にコンパイルエラー                              │ │
│  │  #define CONSOLE (#)                                              │ │
│  │  #define MOBILE (#)                                               │ │
│  │  #define PLATFORM_CONSOLE (#)                                     │ │
│  │                                                                   │ │
│  │  // これらを使おうとすると:                                       │ │
│  │  // error: expected expression before '#' token                   │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 11.2 API バージョニング

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      API バージョニング                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【オーバーロードによる新旧 API の共存】                                │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  // 新 API (推奨)                                                 │ │
│  │  virtual FFileOpenResult OpenRead(                                │ │
│  │      const TCHAR* Filename,                                       │ │
│  │      EOpenReadFlags Flags                                         │ │
│  │  );                                                               │ │
│  │                                                                   │ │
│  │  // 旧 API (後方互換性のため維持)                                 │ │
│  │  virtual IFileHandle* OpenRead(                                   │ │
│  │      const TCHAR* Filename,                                       │ │
│  │      bool bAllowWrite = false                                     │ │
│  │  ) = 0;                                                           │ │
│  │                                                                   │ │
│  │  // 新 API のデフォルト実装は旧 API を呼び出す                    │ │
│  │  virtual FFileOpenResult OpenReadNoBuffering(                     │ │
│  │      const TCHAR* Filename,                                       │ │
│  │      EOpenReadFlags Flags                                         │ │
│  │  )                                                                │ │
│  │  {                                                                │ │
│  │      return OpenRead(Filename, Flags);  // 委譲                   │ │
│  │  }                                                                │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  【段階的移行の原則】                                                   │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │  1. 新 API を追加 (旧 API は維持)                                 │ │
│  │  2. 旧 API に UE_DEPRECATED を追加                                │ │
│  │  3. 数バージョン後に旧 API を削除                                 │ │
│  │                                                                   │ │
│  │  移行期間: 通常 2-3 メジャーバージョン                            │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 12. 設計原則まとめ

### 核心原則

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      HAL 設計原則まとめ                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 【関心の分離】                                                      │
│     • 汎用実装は GenericPlatform/ に配置                               │
│     • プラットフォーム固有実装は専用フォルダに配置                     │
│     • エンジンコードはプラットフォームを意識しない                     │
│                                                                         │
│  2. 【コンパイル時柔軟性】                                              │
│     • プリプロセッサマクロでアーキテクチャ/機能検出                    │
│     • COMPILED_PLATFORM_HEADER で自動ヘッダー選択                      │
│     • 条件コンパイルで不要コードを除外                                 │
│                                                                         │
│  3. 【ランタイム拡張性】                                                │
│     • 仮想インターフェースでランタイムディスパッチ                     │
│     • デコレータパターンでラッパー積み重ね                             │
│     • プラグインによる実装差し替え                                     │
│                                                                         │
│  4. 【ハイブリッドアプローチ】                                          │
│     • コンパイル時とランタイムの決定を適切に使い分け                   │
│     • パフォーマンスクリティカルな部分はコンパイル時に固定             │
│     • 拡張が必要な部分のみ仮想関数を使用                               │
│                                                                         │
│  5. 【テンプレートベース汎用化】                                        │
│     • テンプレートで型安全なコード再利用                               │
│     • ミューテックス等のプリミティブをテンプレート化                   │
│     • プラットフォーム固有実装は特殊化で提供                           │
│                                                                         │
│  6. 【RAII 原則】                                                       │
│     • コンストラクタ/デストラクタでリソース管理                        │
│     • スコープロック、イベント参照等で適用                             │
│     • コピー/ムーブセマンティクスの明示                                │
│                                                                         │
│  7. 【段階的非推奨化】                                                  │
│     • 旧 API を維持しつつ新 API を追加                                 │
│     • 警告を通じて移行を促進                                           │
│     • 十分な移行期間の確保                                             │
│                                                                         │
│  8. 【パフォーマンス最優先】                                            │
│     • FORCEINLINE の戦略的使用                                         │
│     • キャッシュライン最適化                                           │
│     • 仮想関数呼び出しの最小化                                         │
│                                                                         │
│  9. 【エラー処理の一貫性】                                              │
│     • Result 型パターンの採用                                          │
│     • プラットフォーム固有エラーの抽象化                               │
│     • 遅延評価によるエラーメッセージ生成                               │
│                                                                         │
│  10. 【フォールバックメカニズム】                                       │
│      • 未実装機能は汎用実装にフォールバック                            │
│      • 新プラットフォームでも即座に動作可能                            │
│      • 段階的な最適化が可能                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 次のパートへのリンク

- [第1部：アーキテクチャと設計思想](Platform_Abstraction_Layer_Part1.md)
- [第2部：プリプロセッサシステムと型システム](Platform_Abstraction_Layer_Part2.md)
- [第3部：HALコンポーネント詳細](Platform_Abstraction_Layer_Part3.md)
- [第4部：ビルドシステムと新規プラットフォーム追加](Platform_Abstraction_Layer_Part4.md)
- [第5部：スレッディング・クラッシュ処理・ネットワーク・文字列処理](Platform_Abstraction_Layer_Part5.md)
- [第6部：メモリアロケータ詳細ガイド](Platform_Abstraction_Layer_Part6.md)
- [第7部：LLM完全ガイド](Platform_Abstraction_Layer_Part7.md)
- [第8部：デバッグ・診断ツール](Platform_Abstraction_Layer_Part8.md)
- [第9部：プラットフォーム固有機能・システム詳細](Platform_Abstraction_Layer_Part9.md)
- [第10部：コアユーティリティ・非同期システム詳細](Platform_Abstraction_Layer_Part10.md)

---

*このドキュメントはUnreal Engine 5.7のソースコードに基づいています。*
