# 05-03: レンダーターゲットビュー (RTV)

## 目的

レンダーターゲット出力用ビュー（TV（インターフェースを定義する。

## 参照ドキュメント

- 04-02-texture-interface.md (IRHITexture)
- 01-04-types-descriptor.md (RHICPUDescriptorHandle)

## 変更対象ファイル

新規作成:
- `Source/Engine/RHI/Public/IRHIViews.h` (部分

## TODO

### 1. RTV記述構造体

```cpp
namespace NS::RHI
{
    /// レンダーターゲットビュー記述
    struct RHI_API RHIRenderTargetViewDesc
    {
        /// テクスチャ
        IRHITexture* texture = nullptr;

        /// ビューフォーマット（Unknown = テクスチャのフォーマットを使用）。
        EPixelFormat format = EPixelFormat::Unknown;

        /// 次元（テクスチャから自動推論される場合が多い）。
        ERHITextureDimension dimension = ERHITextureDimension::Texture2D;

        //=====================================================================
        // 2Dテクスチャ用
        //=====================================================================

        /// MIPレベル（単一MIPを指定）
        uint32 mipSlice = 0;

        /// 平面スライス（プレーナーフォーマット用）。
        uint32 planeSlice = 0;

        //=====================================================================
        // 配列テクスチャ用
        //=====================================================================

        /// 開始配列スライス
        uint32 firstArraySlice = 0;

        /// 配列サイズ（ = 残り全て）。
        uint32 arraySize = 0;

        //=====================================================================
        // 3Dテクスチャ用
        //=====================================================================

        /// 開始Wスライス
        uint32 firstWSlice = 0;

        /// Wサイズ（ = 残り全て）。
        uint32 wSize = 0;

        //=====================================================================
        // ビルダー
        //=====================================================================

        /// 2Dテクスチャ用デフォルト
        static RHIRenderTargetViewDesc Texture2D(IRHITexture* tex, uint32 mip = 0) {
            RHIRenderTargetViewDesc desc;
            desc.texture = tex;
            desc.dimension = ERHITextureDimension::Texture2D;
            desc.mipSlice = mip;
            return desc;
        }

        /// 2D配列の特定スライス
        static RHIRenderTargetViewDesc Texture2DArray(
            IRHITexture* tex, uint32 mip, uint32 firstSlice, uint32 count = 1)
        {
            RHIRenderTargetViewDesc desc;
            desc.texture = tex;
            desc.dimension = ERHITextureDimension::Texture2DArray;
            desc.mipSlice = mip;
            desc.firstArraySlice = firstSlice;
            desc.arraySize = count;
            return desc;
        }

        /// マルチサンプル用
        static RHIRenderTargetViewDesc Texture2DMS(IRHITexture* tex) {
            RHIRenderTargetViewDesc desc;
            desc.texture = tex;
            desc.dimension = ERHITextureDimension::Texture2DMS;
            return desc;
        }

        /// 3Dテクスチャスライス
        static RHIRenderTargetViewDesc Texture3D(
            IRHITexture* tex, uint32 mip, uint32 firstW, uint32 wSize = 1)
        {
            RHIRenderTargetViewDesc desc;
            desc.texture = tex;
            desc.dimension = ERHITextureDimension::Texture3D;
            desc.mipSlice = mip;
            desc.firstWSlice = firstW;
            desc.wSize = wSize;
            return desc;
        }

        /// キューブマップの面
        static RHIRenderTargetViewDesc CubeFace(
            IRHITexture* tex, ERHICubeFace face, uint32 mip = 0)
        {
            RHIRenderTargetViewDesc desc;
            desc.texture = tex;
            desc.dimension = ERHITextureDimension::Texture2DArray;
            desc.mipSlice = mip;
            desc.firstArraySlice = static_cast<uint32>(face);
            desc.arraySize = 1;
            return desc;
        }
    };
}
```

- [ ] RHIRenderTargetViewDesc 構造体
- [ ] 各ビルダーメソッド

### 2. IRHIRenderTargetView インターフェース

```cpp
namespace NS::RHI
{
    /// レンダーターゲットビュー
    class RHI_API IRHIRenderTargetView : public IRHIResource
    {
    public:
        DECLARE_RHI_RESOURCE_TYPE(RenderTargetView)

        virtual ~IRHIRenderTargetView() = default;

        //=====================================================================
        // 基本プロパティ
        //=====================================================================

        /// 所属デバイス取得
        virtual IRHIDevice* GetDevice() const = 0;

        /// CPUディスクリプタハンドル取得
        virtual RHICPUDescriptorHandle GetCPUHandle() const = 0;

        //=====================================================================
        // ソースリソース
        //=====================================================================

        /// ソーステクスチャ取得
        virtual IRHITexture* GetTexture() const = 0;

        /// MIPレベル取得
        virtual uint32 GetMipSlice() const = 0;

        /// 配列スライス取得
        virtual uint32 GetFirstArraySlice() const = 0;

        /// 配列サイズ取得
        virtual uint32 GetArraySize() const = 0;

        //=====================================================================
        // サイズ情報
        //=====================================================================

        /// ビューの幅取得（IPレベル考（。
        uint32 GetWidth() const {
            IRHITexture* tex = GetTexture();
            return tex ? CalculateMipSize(tex->GetWidth(), GetMipSlice()) : 0;
        }

        /// ビューの高さ取得（IPレベル考（。
        uint32 GetHeight() const {
            IRHITexture* tex = GetTexture();
            return tex ? CalculateMipSize(tex->GetHeight(), GetMipSlice()) : 0;
        }

        /// サイズ取得
        Extent2D GetSize() const {
            return Extent2D{GetWidth(), GetHeight()};
        }

        //=====================================================================
        // フォーマット
        //=====================================================================

        /// ビューフォーマット取得
        virtual EPixelFormat GetFormat() const = 0;

        /// サンプル数取得
        ERHISampleCount GetSampleCount() const {
            IRHITexture* tex = GetTexture();
            return tex ? tex->GetSampleCount() : ERHISampleCount::Count1;
        }

        /// マルチサンプルか
        bool IsMultisampled() const {
            return NS::RHI::IsMultisampled(GetSampleCount());
        }
    };

    using RHIRenderTargetViewRef = TRefCountPtr<IRHIRenderTargetView>;
}
```

- [ ] IRHIRenderTargetView インターフェース
- [ ] サイズ・フォーマット取得

### 3. RTV作成インターフェース

```cpp
namespace NS::RHI
{
    class IRHIDevice
    {
    public:
        //=====================================================================
        // RTV作成
        //=====================================================================

        /// レンダーターゲットビュー作成
        virtual IRHIRenderTargetView* CreateRenderTargetView(
            const RHIRenderTargetViewDesc& desc,
            const char* debugName = nullptr) = 0;

        /// テクスチャからデフォルトTV作成
        IRHIRenderTargetView* CreateDefaultRTV(
            IRHITexture* texture,
            const char* debugName = nullptr)
        {
            return CreateRenderTargetView(
                RHIRenderTargetViewDesc::Texture2D(texture), debugName);
        }

        /// Null RTV取得（未使用スロット用）。
        virtual IRHIRenderTargetView* GetNullRTV() = 0;
    };
}
```

- [ ] CreateRenderTargetView
- [ ] CreateDefaultRTV
- [ ] GetNullRTV

### 4. レンダーターゲット配列

```cpp
namespace NS::RHI
{
    /// 最大レンダーターゲット数
    constexpr uint32 kMaxRenderTargets = 8;

    /// レンダーターゲット配列
    /// 複数RTVをMRTとして設定する際に使用
    struct RHI_API RHIRenderTargetArray
    {
        /// RTV配列
        IRHIRenderTargetView* rtvs[kMaxRenderTargets] = {};

        /// 有効なRTV数
        uint32 count = 0;

        /// クリア
        void Clear() {
            for (uint32 i = 0; i < kMaxRenderTargets; ++i) {
                rtvs[i] = nullptr;
            }
            count = 0;
        }

        /// RTV追加
        bool Add(IRHIRenderTargetView* rtv) {
            if (count >= kMaxRenderTargets) return false;
            rtvs[count++] = rtv;
            return true;
        }

        /// 指定スロットに設定
        void Set(uint32 slot, IRHIRenderTargetView* rtv) {
            if (slot < kMaxRenderTargets) {
                rtvs[slot] = rtv;
                if (slot >= count) count = slot + 1;
            }
        }

        /// 取得
        IRHIRenderTargetView* Get(uint32 slot) const {
            return slot < kMaxRenderTargets ? rtvs[slot] : nullptr;
        }

        /// 空か
        bool IsEmpty() const { return count == 0; }

        /// 全RTVが同じサイズか確認
        bool ValidateSizeConsistency() const;

        /// 共通サイズ取得（最初のRTVのサイズ）。
        Extent2D GetCommonSize() const {
            return (count > 0 && rtvs[0]) ? rtvs[0]->GetSize() : Extent2D{0, 0};
        }
    };
}
```

- [ ] RHIRenderTargetArray 構造体
- [ ] kMaxRenderTargets 定数

### 5. レンダーターゲットクリア

```cpp
namespace NS::RHI
{
    /// レンダーターゲットクリア値
    struct RHI_API RHIRTVClearValue
    {
        float color[4] = {0.0f, 0.0f, 0.0f, 0.0f};

        RHIRTVClearValue() = default;

        RHIRTVClearValue(float r, float g, float b, float a = 1.0f) {
            color[0] = r;
            color[1] = g;
            color[2] = b;
            color[3] = a;
        }

        static RHIRTVClearValue Black() { return RHIRTVClearValue(0, 0, 0, 1); }
        static RHIRTVClearValue White() { return RHIRTVClearValue(1, 1, 1, 1); }
        static RHIRTVClearValue Transparent() { return RHIRTVClearValue(0, 0, 0, 0); }
        static RHIRTVClearValue Red() { return RHIRTVClearValue(1, 0, 0, 1); }
        static RHIRTVClearValue Green() { return RHIRTVClearValue(0, 1, 0, 1); }
        static RHIRTVClearValue Blue() { return RHIRTVClearValue(0, 0, 1, 1); }
    };

    /// レンダーターゲットクリア操作（RHICommandContextに追加）。
    class IRHICommandContext
    {
    public:
        /// レンダーターゲットクリア
        virtual void ClearRenderTargetView(
            IRHIRenderTargetView* rtv,
            const float color[4]) = 0;

        /// 便利関数
        void ClearRTV(IRHIRenderTargetView* rtv, const RHIRTVClearValue& value) {
            ClearRenderTargetView(rtv, value.color);
        }

        /// 複数RTVをクリア
        void ClearRenderTargets(
            const RHIRenderTargetArray& targets,
            const RHIRTVClearValue& value)
        {
            for (uint32 i = 0; i < targets.count; ++i) {
                if (targets.rtvs[i]) {
                    ClearRenderTargetView(targets.rtvs[i], value.color);
                }
            }
        }
    };
}
```

- [ ] RHIRTVClearValue 構造体
- [ ] ClearRenderTargetView
- [ ] ClearRenderTargets

## 検証方法

- [ ] RTV作成と参照整合性
- [ ] サイズ計算の正確性
- [ ] MRT配列の検証
- [ ] クリア操作の動作確認
