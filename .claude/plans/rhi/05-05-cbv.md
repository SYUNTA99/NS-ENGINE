# 05-05: 定数バッファビュー (CBV)

## 目的

定数バッファ用ビュー（BV（インターフェースを定義する。

## 参照ドキュメント

- 03-02-buffer-interface.md (IRHIBuffer)
- 01-04-types-descriptor.md (RHICPUDescriptorHandle)

## 変更対象ファイル

新規作成:
- `Source/Engine/RHI/Public/IRHIViews.h` (部分

## TODO

### 1. CBV記述構造体

```cpp
namespace NS::RHI
{
    /// 定数バッファビュー記述
    struct RHI_API RHIConstantBufferViewDesc
    {
        /// バッファがnullの場合（GPUアドレスを直接使用）。
        IRHIBuffer* buffer = nullptr;

        /// バッファ内オフセット（256バイトアライメント必要）
        MemoryOffset offset = 0;

        /// サイズ（256バイトアライメント必要、0 = バッファ全体）
        MemorySize size = 0;

        /// GPUアドレス直接指定（Bufferがnullの場合に使用）。
        uint64 gpuAddress = 0;

        //=====================================================================
        // ビルダー
        //=====================================================================

        /// バッファから作成
        static RHIConstantBufferViewDesc FromBuffer(
            IRHIBuffer* buf,
            MemoryOffset off = 0,
            MemorySize sz = 0)
        {
            RHIConstantBufferViewDesc desc;
            desc.buffer = buf;
            desc.offset = off;
            desc.size = sz;
            return desc;
        }

        /// GPUアドレスから作成
        static RHIConstantBufferViewDesc FromGPUAddress(
            uint64 address,
            MemorySize sz)
        {
            RHIConstantBufferViewDesc desc;
            desc.gpuAddress = address;
            desc.size = sz;
            return desc;
        }

        /// 有効なGPUアドレス取得
        uint64 GetEffectiveGPUAddress() const {
            return buffer ? buffer->GetGPUVirtualAddress() + offset : gpuAddress;
        }

        /// 有効なサイズ取得
        MemorySize GetEffectiveSize() const {
            if (size > 0) return size;
            return buffer ? buffer->GetSize() - offset : 0;
        }

        /// アライメント検証
        bool ValidateAlignment() const {
            return IsAligned(offset, kConstantBufferAlignment) &&
                   IsAligned(GetEffectiveSize(), kConstantBufferAlignment);
        }
    };
}
```

- [ ] RHIConstantBufferViewDesc 構造体
- [ ] FromBuffer / FromGPUAddress ビルダー
- [ ] アライメント検証

### 2. IRHIConstantBufferView インターフェース

```cpp
namespace NS::RHI
{
    /// 定数バッファビュー
    class RHI_API IRHIConstantBufferView : public IRHIResource
    {
    public:
        DECLARE_RHI_RESOURCE_TYPE(ConstantBufferView)

        virtual ~IRHIConstantBufferView() = default;

        //=====================================================================
        // 基本プロパティ
        //=====================================================================

        /// 所属デバイス取得
        virtual IRHIDevice* GetDevice() const = 0;

        /// CPUディスクリプタハンドル取得
        virtual RHICPUDescriptorHandle GetCPUHandle() const = 0;

        /// GPUディスクリプタハンドル取得
        virtual RHIGPUDescriptorHandle GetGPUHandle() const = 0;

        /// Bindlessインデックス取得
        virtual BindlessIndex GetBindlessIndex() const = 0;

        //=====================================================================
        // ソースリソース
        //=====================================================================

        /// ソースバッファ取得（nullの場合あり）
        virtual IRHIBuffer* GetBuffer() const = 0;

        /// GPUアドレス取得
        virtual uint64 GetGPUVirtualAddress() const = 0;

        /// オフセット取得
        virtual MemoryOffset GetOffset() const = 0;

        /// サイズ取得
        virtual MemorySize GetSize() const = 0;

        //=====================================================================
        // データアクセス（バッファがある場合）
        //=====================================================================

        /// データを更新（バッファがCPU書き込み可能な場合）
        bool UpdateData(const void* data, MemorySize dataSize, MemoryOffset localOffset = 0) {
            IRHIBuffer* buf = GetBuffer();
            if (!buf || !buf->IsCPUWritable()) return false;
            return buf->WriteData(data, dataSize, GetOffset() + localOffset);
        }

        /// 型付きデータを更新
        template<typename T>
        bool Update(const T& value) {
            return UpdateData(&value, sizeof(T));
        }
    };

    using RHIConstantBufferViewRef = TRefCountPtr<IRHIConstantBufferView>;
}
```

- [ ] IRHIConstantBufferView インターフェース
- [ ] UpdateData / Update テンプレート

### 3. CBV作成インターフェース

```cpp
namespace NS::RHI
{
    class IRHIDevice
    {
    public:
        //=====================================================================
        // CBV作成
        //=====================================================================

        /// 定数バッファビュー作成
        virtual IRHIConstantBufferView* CreateConstantBufferView(
            const RHIConstantBufferViewDesc& desc,
            const char* debugName = nullptr) = 0;

        /// バッファからデフォルトBV作成
        IRHIConstantBufferView* CreateDefaultCBV(
            IRHIBuffer* buffer,
            const char* debugName = nullptr)
        {
            return CreateConstantBufferView(
                RHIConstantBufferViewDesc::FromBuffer(buffer), debugName);
        }

        /// Null CBV取得
        virtual IRHIConstantBufferView* GetNullCBV() = 0;
    };
}
```

- [ ] CreateConstantBufferView
- [ ] CreateDefaultCBV
- [ ] GetNullCBV

### 4. インライン定数（ルート定数）。

```cpp
namespace NS::RHI
{
    /// ルート定数データ
    /// 小さなデータをデスクリプタなしで直接シェーダーに渡す
    struct RHI_API RHIRootConstants
    {
        /// データ（最大256バイト推奨）。
        uint8 data[256];

        /// 使用サイズ（バイト）
        uint32 size = 0;

        /// DWORDカウント
        uint32 GetDWORDCount() const { return (size + 3) / 4; }

        /// データ設定
        template<typename T>
        void Set(const T& value) {
            static_assert(sizeof(T) <= sizeof(data), "Root constants too large");
            std::memcpy(data, &value, sizeof(T));
            size = sizeof(T);
        }

        /// 配列データ設定
        void SetRaw(const void* srcData, uint32 srcSize) {
            RHI_CHECK(srcSize <= sizeof(data));
            std::memcpy(data, srcData, srcSize);
            size = srcSize;
        }
    };

    /// ルート定数設定（RHICommandContextに追加）。
    class IRHICommandContext
    {
    public:
        /// グラフィックス用ルート定数設定
        virtual void SetGraphicsRoot32BitConstants(
            uint32 rootParameterIndex,
            uint32 num32BitValues,
            const void* data,
            uint32 destOffset = 0) = 0;

        /// 便利関数
        template<typename T>
        void SetGraphicsRootConstants(uint32 rootIndex, const T& value) {
            static_assert(sizeof(T) % 4 == 0, "Size must be multiple of 4 bytes");
            SetGraphicsRoot32BitConstants(rootIndex, sizeof(T) / 4, &value);
        }
    };

    class IRHIComputeContext
    {
    public:
        /// コンピュート用ルート定数設定
        virtual void SetComputeRoot32BitConstants(
            uint32 rootParameterIndex,
            uint32 num32BitValues,
            const void* data,
            uint32 destOffset = 0) = 0;

        template<typename T>
        void SetComputeRootConstants(uint32 rootIndex, const T& value) {
            static_assert(sizeof(T) % 4 == 0, "Size must be multiple of 4 bytes");
            SetComputeRoot32BitConstants(rootIndex, sizeof(T) / 4, &value);
        }
    };
}
```

- [ ] RHIRootConstants 構造体
- [ ] SetGraphicsRoot32BitConstants / SetComputeRoot32BitConstants

### 5. 定数バッファリング（マルチバッファリング）。

```cpp
namespace NS::RHI
{
    /// 定数バッファリングヘルパー
    /// フレームごとに異なるバッファを使用してCPU-GPU同期を回避
    template<typename T, uint32 BufferCount = 3>
    class RHIConstantBufferRing
    {
    public:
        RHIConstantBufferRing() = default;

        /// 初期化
        bool Initialize(IRHIDevice* device, const char* debugName = nullptr) {
            for (uint32 i = 0; i < BufferCount; ++i) {
                char name[128];
                if (debugName) {
                    snprintf(name, sizeof(name), "%s[%u]", debugName, i);
                }

                auto desc = CreateConstantBufferDesc(GetConstantBufferSize<T>(), true);
                desc.debugName = debugName ? name : nullptr;

                m_buffers[i] = device->CreateBuffer(desc);
                if (!m_buffers[i]) return false;

                m_cbvs[i] = device->CreateDefaultCBV(m_buffers[i].Get());
                if (!m_cbvs[i]) return false;
            }
            return true;
        }

        /// フレーム開始時に呼び出す
        void BeginFrame() {
            m_currentIndex = (m_currentIndex + 1) % BufferCount;
        }

        /// 現在のバッファにデータを更新
        bool Update(const T& data) {
            if (!m_buffers[m_currentIndex]) return false;
            return m_buffers[m_currentIndex]->Write(data);
        }

        /// 現在のCBV取得
        IRHIConstantBufferView* GetCurrentCBV() const {
            return m_cbvs[m_currentIndex].Get();
        }

        /// 現在のバッファ取得
        IRHIBuffer* GetCurrentBuffer() const {
            return m_buffers[m_currentIndex].Get();
        }

        /// GPUアドレス取得
        uint64 GetCurrentGPUAddress() const {
            auto* buf = GetCurrentBuffer();
            return buf ? buf->GetGPUVirtualAddress() : 0;
        }

    private:
        RHIBufferRef m_buffers[BufferCount];
        RHIConstantBufferViewRef m_cbvs[BufferCount];
        uint32 m_currentIndex = 0;
    };
}
```

- [ ] RHIConstantBufferRing テンプレート
- [ ] BeginFrame / Update / GetCurrentCBV

## 検証方法

- [ ] CBV作成と参照整合性
- [ ] アライメント検証の正確性
- [ ] ルート定数の設定動作
- [ ] マルチバッファリングの動作
