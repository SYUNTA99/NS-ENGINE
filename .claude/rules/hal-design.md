# HAL（Hardware Abstraction Layer）設計原則

ハードウェア・OS固有機能の抽象化レイヤー。

---

## 設計原則

┌─────────────────────────────────────────────────────────────────────────┐
│                      HAL 設計原則まとめ                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 【関心の分離】                                                      │
│     • 汎用実装は GenericPlatform/ に配置                               │
│     • プラットフォーム固有実装は専用フォルダに配置                     │
│     • エンジンコードはプラットフォームを意識しない                     │
│                                                                         │
│  2. 【コンパイル時柔軟性】                                              │
│     • プリプロセッサマクロでアーキテクチャ/機能検出                    │
│     • COMPILED_PLATFORM_HEADER で自動ヘッダー選択                      │
│     • 条件コンパイルで不要コードを除外                                 │
│                                                                         │
│  3. 【ランタイム拡張性】                                                │
│     • 仮想インターフェースでランタイムディスパッチ                     │
│     • デコレータパターンでラッパー積み重ね                             │
│     • プラグインによる実装差し替え                                     │
│                                                                         │
│  4. 【ハイブリッドアプローチ】                                          │
│     • コンパイル時とランタイムの決定を適切に使い分け                   │
│     • パフォーマンスクリティカルな部分はコンパイル時に固定             │
│     • 拡張が必要な部分のみ仮想関数を使用                               │
│                                                                         │
│  5. 【テンプレートベース汎用化】                                        │
│     • テンプレートで型安全なコード再利用                               │
│     • ミューテックス等のプリミティブをテンプレート化                   │
│     • プラットフォーム固有実装は特殊化で提供                           │
│                                                                         │
│  6. 【RAII 原則】                                                       │
│     • コンストラクタ/デストラクタでリソース管理                        │
│     • スコープロック、イベント参照等で適用                             │
│     • コピー/ムーブセマンティクスの明示                                │
│                                                                         │
│  7. 【段階的非推奨化】                                                  │
│     • 旧 API を維持しつつ新 API を追加                                 │
│     • 警告を通じて移行を促進                                           │
│     • 十分な移行期間の確保                                             │
│                                                                         │
│  8. 【パフォーマンス最優先】                                            │
│     • FORCEINLINE の戦略的使用                                         │
│     • キャッシュライン最適化                                           │
│     • 仮想関数呼び出しの最小化                                         │
│                                                                         │
│  9. 【エラー処理の一貫性】                                              │
│     • Result 型パターンの採用                                          │
│     • プラットフォーム固有エラーの抽象化                               │
│     • 遅延評価によるエラーメッセージ生成                               │
│                                                                         │
│  10. 【フォールバックメカニズム】                                       │
│      • 未実装機能は汎用実装にフォールバック                            │
│      • 新プラットフォームでも即座に動作可能                            │
│      • 段階的な最適化が可能                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘

### 5. Resultベースエラー処理

OS APIのエラーを`NS::Result`に変換。


## 禁止事項

| 禁止 | 理由 | 代替 |
|------|------|------|
| Public APIでのOS固有型 | 移植性喪失 | 抽象インターフェース |
| 生ポインタでのリソース所有 | リーク | RAII、スマートポインタ |
| 例外 | パフォーマンス | `NS::Result` |
| グローバル状態 | テスト困難 | 依存性注入 |
| プリプロセッサでのプラットフォーム分岐（Public） | 可読性低下 | 実装ファイルで分離 |

---

