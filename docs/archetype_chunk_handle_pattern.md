# Archetype-Chunk-Handle (ACH) パターン

## ECSの効率性とOOPの直感性を両立する軽量アプローチ

---

## 1. 概要

ACHパターンは、ECSの3つの柱（Archetype、Chunk、並列化）を基盤としながら、OOP的な操作感を「Handle」という軽量な参照層で実現する設計パターンである。

前回提案した「Projection with Batch Commit」パターンとは異なり、遅延書き込みを行わず、直接アクセスによる即時反映を特徴とする。

```
┌─────────────────────────────────────────────────────────────────┐
│                      ACH パターンの構成                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  Archetype（型の組み合わせ）                            │   │
│   │    Player = [Position, Velocity, Health, Input]         │   │
│   │    Enemy  = [Position, Velocity, Health, AI]            │   │
│   └─────────────────────────────────────────────────────────┘   │
│                            ↓                                    │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  Chunk（連続メモリブロック）                            │   │
│   │    同じArchetypeのEntityを固定サイズで格納              │   │
│   └─────────────────────────────────────────────────────────┘   │
│                            ↓                                    │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  Handle（軽量参照）                                     │   │
│   │    Chunk + Index で直接アクセス                         │   │
│   │    OOP的なメソッド呼び出しを提供                        │   │
│   └─────────────────────────────────────────────────────────┘   │
│                            ↓                                    │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  並列化（Chunk単位）                                    │   │
│   │    各Chunkを独立したスレッドで処理                      │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 基盤技術の解説

### 2.1 Archetype（アーキタイプ）

Archetypeとは、「どのコンポーネントを持つか」という組み合わせを表す概念である。OOPの「クラス」に相当するが、継承関係ではなくコンポーネントの集合で定義される。

```
┌─────────────────────────────────────────────────────────────────┐
│                    Archetype の概念                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  OOP的な考え方:                                                 │
│    class Player { Position pos; Velocity vel; Health hp; }     │
│                                                                 │
│  ECS (Archetype) 的な考え方:                                   │
│    Player = コンポーネントの集合 {Position, Velocity, Health}  │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Archetype A: {Position, Velocity}                      │   │
│  │  Archetype B: {Position, Velocity, Health}              │   │
│  │  Archetype C: {Position, Velocity, Health, Input}       │   │
│  │  Archetype D: {Position, Velocity, Health, AI}          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  → 同じコンポーネント構成のEntityは同じArchetypeに属する       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 Chunk（チャンク）

Chunkは、同じArchetypeに属するEntityのデータを格納する連続メモリブロックである。固定サイズ（例: 16KB）で、一定数のEntityを収容する。

```
┌─────────────────────────────────────────────────────────────────┐
│                      Chunk の構造                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Archetype: Player {Position, Velocity, Health}                │
│                                                                 │
│  ┌─────────────────────────── Chunk ───────────────────────┐   │
│  │                                                         │   │
│  │  Position配列:  [P0] [P1] [P2] [P3] [P4] ... [Pn]      │   │
│  │  Velocity配列:  [V0] [V1] [V2] [V3] [V4] ... [Vn]      │   │
│  │  Health配列:    [H0] [H1] [H2] [H3] [H4] ... [Hn]      │   │
│  │                                                         │   │
│  │  Entity数: n+1                                          │   │
│  │  サイズ: 固定（例: 16KB）                               │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  特徴:                                                          │
│    - 同じ型のデータが連続 → キャッシュ効率が高い               │
│    - 固定サイズ → メモリ管理が単純                             │
│    - Chunk内のデータは独立 → 並列処理可能                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 SoA（Structure of Arrays）配置

Chunk内のデータは、AoS（Array of Structures）ではなくSoA（Structure of Arrays）で配置される。これがキャッシュ効率の鍵である。

```
┌─────────────────────────────────────────────────────────────────┐
│                   AoS vs SoA の比較                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ■ AoS（Array of Structures）- OOP的な配置                     │
│                                                                 │
│    メモリ: [P0,V0,H0] [P1,V1,H1] [P2,V2,H2] [P3,V3,H3] ...    │
│                                                                 │
│    Position だけ処理したい時:                                  │
│      P0 → (V0,H0をスキップ) → P1 → (V1,H1をスキップ) → ...   │
│      → キャッシュに無駄なデータが載る                          │
│                                                                 │
│  ■ SoA（Structure of Arrays）- ECS的な配置                     │
│                                                                 │
│    メモリ: [P0,P1,P2,P3...] [V0,V1,V2,V3...] [H0,H1,H2,H3...]  │
│                                                                 │
│    Position だけ処理したい時:                                  │
│      P0 → P1 → P2 → P3 → ... （連続アクセス）                 │
│      → キャッシュラインを最大限活用                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. Handle（ハンドル）の設計

### 3.1 Handleとは

HandleはChunk内の特定Entityへの「直接参照」である。Chunk ポインタとインデックスの組で構成され、間接参照（IDルックアップ）を回避する。

```
┌─────────────────────────────────────────────────────────────────┐
│                    Handle の仕組み                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  従来のECS（間接参照）:                                        │
│                                                                 │
│    EntityID → Registry検索 → Archetype特定 → Chunk特定        │
│             → Index特定 → データアクセス                       │
│                                                                 │
│    → 毎回ルックアップが発生、オーバーヘッド大                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────     │
│                                                                 │
│  Handle（直接参照）:                                           │
│                                                                 │
│    Handle = (Chunk*, Index)                                    │
│           ↓                                                    │
│    chunk->position[index]  ← 即座にアクセス                   │
│                                                                 │
│    → ルックアップなし、ポインタ演算のみ                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 Handleの寿命

Handleは「Chunkイテレーション中」のみ有効である。これは制約ではあるが、System内での使用には十分であり、この制約があるからこそ軽量さを実現できる。

```
┌─────────────────────────────────────────────────────────────────┐
│                    Handle の寿命                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────── System 実行開始 ───────────┐                     │
│  │                                        │                     │
│  │  for (Chunk* chunk : archetype) {      │                     │
│  │      for (int i = 0; i < count; i++) { │                     │
│  │                                        │                     │
│  │          PlayerHandle h{chunk, i};     │ ← Handle生成       │
│  │          h.Move(10);                   │ ← 有効             │
│  │          h.TakeDamage(5);              │ ← 有効             │
│  │                                        │                     │
│  │      }  ← Handle の寿命終了            │                     │
│  │  }                                     │                     │
│  │                                        │                     │
│  └────────────────────────────────────────┘                     │
│                                                                 │
│  System外でEntityを参照したい場合:                             │
│    → EntityID（安定ID）を使用                                  │
│    → 次のSystem実行時にHandleを再取得                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 HandleによるOOP的操作

Handleにメソッドを定義することで、OOP的な操作感を実現する。

```
┌─────────────────────────────────────────────────────────────────┐
│                  Handle の OOP的インターフェース                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PlayerHandle の構成:                                          │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  データ:                                                │   │
│  │    - Chunk* chunk  （どのChunkか）                      │   │
│  │    - int index     （Chunk内の何番目か）                │   │
│  │                                                         │   │
│  │  アクセサ:                                              │   │
│  │    - position() → chunk->position[index]               │   │
│  │    - velocity() → chunk->velocity[index]               │   │
│  │    - health()   → chunk->health[index]                 │   │
│  │                                                         │   │
│  │  メソッド:                                              │   │
│  │    - Move(dx, dy)     位置を移動                       │   │
│  │    - TakeDamage(amt)  ダメージを受ける                 │   │
│  │    - Heal(amt)        回復する                         │   │
│  │    - IsAlive()        生存判定                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  使用例:                                                        │
│                                                                 │
│    PlayerHandle player{chunk, i};                              │
│    player.Move(10, 0);          // OOP的なメソッド呼び出し     │
│    player.TakeDamage(5);                                       │
│    if (!player.IsAlive()) {                                    │
│        // 死亡処理                                             │
│    }                                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 並列化との統合

### 4.1 Chunk単位の並列処理

各Chunkは独立したデータを持つため、異なるChunkを異なるスレッドで同時に処理できる。

```
┌─────────────────────────────────────────────────────────────────┐
│                    Chunk単位の並列化                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Archetype: Player                                             │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐              │
│  │ Chunk 0 │ │ Chunk 1 │ │ Chunk 2 │ │ Chunk 3 │              │
│  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘              │
│       │           │           │           │                    │
│       ▼           ▼           ▼           ▼                    │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐              │
│  │Thread 0 │ │Thread 1 │ │Thread 2 │ │Thread 3 │              │
│  │         │ │         │ │         │ │         │              │
│  │ for i:  │ │ for i:  │ │ for i:  │ │ for i:  │              │
│  │  Handle │ │  Handle │ │  Handle │ │  Handle │              │
│  │  h{c,i} │ │  h{c,i} │ │  h{c,i} │ │  h{c,i} │              │
│  │  h.Do() │ │  h.Do() │ │  h.Do() │ │  h.Do() │              │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘              │
│                                                                 │
│  各スレッドは自分のChunkだけを処理                             │
│  → 同期不要、ロックフリー                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 なぜ安全に並列化できるのか

```
┌─────────────────────────────────────────────────────────────────┐
│                    並列化の安全性                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ■ Chunk間の独立性                                             │
│                                                                 │
│    Chunk A のデータ: [P0,P1,P2...] [V0,V1,V2...] [H0,H1,H2...] │
│    Chunk B のデータ: [P0,P1,P2...] [V0,V1,V2...] [H0,H1,H2...] │
│                                                                 │
│    → 完全に別のメモリ領域                                      │
│    → 同時に書き込んでも競合しない                              │
│                                                                 │
│  ■ Handle の局所性                                             │
│                                                                 │
│    Handle は自分の Chunk 内だけを参照                          │
│    他の Chunk のデータには触れない                             │
│                                                                 │
│    → スレッド間でデータ共有なし                                │
│    → 同期機構不要                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. Relationship（関係性）の扱い

### 5.1 Entity間の関係性

OOPでは `player.weapon` のような所有関係を自然に表現できる。ECSでこれをどう扱うか。

```
┌─────────────────────────────────────────────────────────────────┐
│                    関係性の問題                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  OOPでの表現:                                                   │
│                                                                 │
│    player.weapon.damage     // 自然にアクセス可能              │
│    player.inventory[0]      // コレクションも自然              │
│    enemy.target             // 他Entityへの参照                │
│                                                                 │
│  素朴なECSでの表現:                                            │
│                                                                 │
│    weaponId = player.get<Equipment>().weaponId;                │
│    weapon = registry.get<Weapon>(weaponId);  // 再ルックアップ │
│    damage = weapon.damage;                                     │
│                                                                 │
│    → 間接的で冗長                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 Relationship Chunk

関係性自体もChunkとして管理することで、効率的な一括処理を可能にする。

```
┌─────────────────────────────────────────────────────────────────┐
│                  Relationship Chunk                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  関係性「Owns<Weapon>」をChunk化:                              │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  Relationship Chunk: Owns<Weapon>                         │ │
│  │                                                           │ │
│  │  Owner配列:    [Player1] [Player2] [Player3] ...         │ │
│  │  Owned配列:    [Sword1]  [Axe1]    [Bow1]    ...         │ │
│  │  RelData配列:  [slot:0]  [slot:0]  [slot:1]  ...         │ │
│  │                                                           │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  利点:                                                          │
│    - 「装備している全Player」を一括処理可能                    │
│    - 関係性の追加/削除が効率的                                 │
│    - 関係性にメタデータ（装備スロットなど）を持たせられる      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 逆引きインデックス

`player.weapon()` のようなアクセスを O(1) で実現するため、逆引きインデックスを持つ。

```
┌─────────────────────────────────────────────────────────────────┐
│                    逆引きインデックス                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Entity Metadata:                                              │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Player1:                                               │   │
│  │    archetype: (Chunk_A, index: 3)                      │   │
│  │    relationships:                                       │   │
│  │      Owns<Weapon>:  (RelChunk_1, index: 0) → Sword1    │   │
│  │      Owns<Armor>:   (RelChunk_2, index: 5) → Plate1    │   │
│  │      ChildOf<Team>: (RelChunk_3, index: 2) → TeamA     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  アクセスの流れ:                                               │
│                                                                 │
│    player.weapon()                                             │
│      ↓                                                         │
│    metadata[player].relationships[Owns<Weapon>]                │
│      ↓                                                         │
│    (RelChunk_1, index: 0)                                      │
│      ↓                                                         │
│    RelChunk_1->owned[0] = Sword1                               │
│      ↓                                                         │
│    WeaponHandle{sword1_chunk, sword1_index}                    │
│                                                                 │
│  → O(1) でアクセス可能                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.4 Handle経由での関係性アクセス

```
┌─────────────────────────────────────────────────────────────────┐
│                関係性を含むHandle                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PlayerHandle の拡張:                                          │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  データ:                                                │   │
│  │    - Chunk* chunk                                       │   │
│  │    - int index                                          │   │
│  │    - EntityMetadata* meta  ← 関係性情報を持つ          │   │
│  │                                                         │   │
│  │  関係性アクセサ:                                        │   │
│  │    - weapon()  → WeaponHandle                          │   │
│  │    - armor()   → ArmorHandle                           │   │
│  │    - team()    → TeamHandle                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  使用例:                                                        │
│                                                                 │
│    PlayerHandle player{...};                                   │
│    WeaponHandle weapon = player.weapon();                      │
│    float damage = weapon.damage();     // OOP的なチェーン      │
│                                                                 │
│    player.weapon().Enchant(Fire);      // メソッドチェーン     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 継承の代替：Composition

### 6.1 OOP継承の問題

ECSには継承の概念がない。しかし、コンポーネントの組み合わせ（Composition）で同等の機能を実現できる。

```
┌─────────────────────────────────────────────────────────────────┐
│                    継承 vs Composition                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ■ OOP継承                                                     │
│                                                                 │
│    Character（基底クラス）                                     │
│        ├── Player（派生）                                      │
│        └── Enemy（派生）                                       │
│                                                                 │
│    共通処理: Character* c = ...; c->Move();                    │
│                                                                 │
│  ■ ECS Composition                                             │
│                                                                 │
│    共通コンポーネント: {Position, Velocity, Health}            │
│                                                                 │
│    Player = 共通 + {Input, Inventory}                          │
│    Enemy  = 共通 + {AI, LootTable}                             │
│                                                                 │
│    共通処理: 共通コンポーネントを持つ全Entityに適用            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 共通処理の実現

```
┌─────────────────────────────────────────────────────────────────┐
│                    共通処理の実装                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  MovementSystem:                                               │
│                                                                 │
│    対象: {Position, Velocity} を持つ全Entity                   │
│          （Player も Enemy も NPC も全て含む）                 │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Archetype A: Player {Pos, Vel, Health, Input}         │   │
│  │  Archetype B: Enemy  {Pos, Vel, Health, AI}            │   │
│  │  Archetype C: NPC    {Pos, Vel, Dialog}                │   │
│  │                                                         │   │
│  │  MovementSystem は A, B, C 全てを処理                   │   │
│  │  （{Pos, Vel} を持つ全Archetype）                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  → 継承なしで共通処理を実現                                    │
│  → 新しいArchetypeを追加しても自動的に対象になる              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────┐
│                    ACH パターン 全体像                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                      Registry                           │   │
│  │                                                         │   │
│  │  ┌─────────────────────────────────────────────────┐   │   │
│  │  │  Archetype Storage                              │   │   │
│  │  │                                                 │   │   │
│  │  │  Archetype A ─┬─ Chunk 0                       │   │   │
│  │  │               ├─ Chunk 1                       │   │   │
│  │  │               └─ Chunk 2                       │   │   │
│  │  │                                                 │   │   │
│  │  │  Archetype B ─┬─ Chunk 0                       │   │   │
│  │  │               └─ Chunk 1                       │   │   │
│  │  └─────────────────────────────────────────────────┘   │   │
│  │                                                         │   │
│  │  ┌─────────────────────────────────────────────────┐   │   │
│  │  │  Relationship Storage                           │   │   │
│  │  │                                                 │   │   │
│  │  │  Owns<Weapon>  ─── RelChunk 0                  │   │   │
│  │  │  ChildOf<Team> ─── RelChunk 0                  │   │   │
│  │  └─────────────────────────────────────────────────┘   │   │
│  │                                                         │   │
│  │  ┌─────────────────────────────────────────────────┐   │   │
│  │  │  Entity Metadata（逆引きIndex）                 │   │   │
│  │  │                                                 │   │   │
│  │  │  Entity 0 → (Archetype A, Chunk 0, Index 3)    │   │   │
│  │  │  Entity 1 → (Archetype B, Chunk 1, Index 0)    │   │   │
│  │  └─────────────────────────────────────────────────┘   │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    System 実行                          │   │
│  │                                                         │   │
│  │  1. 対象Archetypeを特定                                │   │
│  │  2. 各Chunkを並列に処理                                │   │
│  │  3. Chunk内でHandleを生成してOOP的操作                 │   │
│  │                                                         │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐               │   │
│  │  │Thread 0 │  │Thread 1 │  │Thread 2 │               │   │
│  │  │ Chunk A │  │ Chunk B │  │ Chunk C │               │   │
│  │  │         │  │         │  │         │               │   │
│  │  │ Handle  │  │ Handle  │  │ Handle  │               │   │
│  │  │  ↓      │  │  ↓      │  │  ↓      │               │   │
│  │  │ OOP操作 │  │ OOP操作 │  │ OOP操作 │               │   │
│  │  └─────────┘  └─────────┘  └─────────┘               │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. Projection パターンとの比較

```
┌─────────────────────────────────────────────────────────────────┐
│            ACH vs Projection with Batch Commit                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  項目              │ Projection        │ ACH                   │
│  ─────────────────┼───────────────────┼─────────────────────  │
│  データ配置        │ ECS               │ ECS (Archetype+Chunk) │
│  書き込み方式      │ 遅延（pending）   │ 即時（直接）          │
│  Commit処理        │ 必要              │ 不要                  │
│  オーバーヘッド    │ pending管理       │ ほぼゼロ              │
│  関係性サポート    │ なし              │ Relationship Chunk    │
│  並列化            │ △（Commit時注意） │ ◎（Chunk単位）        │
│  Handle寿命        │ 柔軟              │ Chunk内限定           │
│  メモリ使用        │ pending分増加     │ 最小                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    使い分けの指針                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ■ ACH が向いているケース                                      │
│    - パフォーマンス最優先                                      │
│    - Chunk単位の並列化を活用したい                             │
│    - Entity間の関係性が複雑                                    │
│    - System内での一時的な操作が中心                            │
│                                                                 │
│  ■ Projection が向いているケース                               │
│    - 複数Systemにまたがる操作が多い                            │
│    - Handle を長期間保持したい                                 │
│    - 書き込みの一括最適化が有効な場面                          │
│    - 既存のECS実装に後付けしたい                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 9. 評価まとめ

### ECS観点

| 項目 | 評価 | 理由 |
|------|:----:|------|
| キャッシュ効率 | ◎ | Chunk内SoA配置、連続アクセス |
| 並列化 | ◎ | Chunk単位で完全独立、ロックフリー |
| 一括処理 | ◎ | Archetype単位でフィルタリング |
| メモリ効率 | ◎ | 余分なバッファなし |

### OOP観点

| 項目 | 評価 | 理由 |
|------|:----:|------|
| 論理的まとまり | ◎ | Handle + Relationship で集約 |
| メソッド記述 | ○ | Handleメソッド or フリー関数 |
| 継承 | △ | Compositionで代替 |
| 関係性 | ◎ | Relationship Chunk + 逆引き |

### 総合

| 項目 | 評価 | 理由 |
|------|:----:|------|
| 実装複雑度 | 中 | Relationship層が追加 |
| 学習コスト | 中 | Handle/Chunkの概念理解が必要 |
| オーバーヘッド | 最小 | 遅延書き込みなし |
| 柔軟性 | ○ | Handle寿命の制約あり |

---

## 10. 結論

**Archetype-Chunk-Handle (ACH) パターン** は、ECSの効率性を最大限に活かしながら、OOP的な操作感を軽量なHandle層で提供するアプローチである。

**核心的なアイデア:**
1. **Archetype + Chunk** によるデータの物理的最適化
2. **Chunk-Local Handle** によるOOP的インターフェース
3. **Relationship Chunk** によるEntity間関係の効率的管理
4. **Chunk単位並列化** によるスケーラビリティ

Projectionパターンと比較して、遅延書き込みを排除することでオーバーヘッドを最小化し、より「生の」ECS効率に近い性能を実現する。一方で、Handleの寿命がChunkイテレーション中に限定されるというトレードオフがある。

大規模な並列処理が必要なゲームエンジンやシミュレーションにおいて、特に有効なパターンである。
