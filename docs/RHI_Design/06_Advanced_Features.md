# RHI 設計仕様 — 高度な機能

---

## 1. レイトレーシング

### 意図（Intent）
明示的なジオメトリ走査なしに、ハードウェア加速されたレイ交差テストを提供し、
リアルな照明・反射・グローバルイルミネーションを実現する。

### 2層加速構造

```
┌─────────────────────────────────────────────────────────┐
│ Top-Level Acceleration Structure (TLAS)                  │
│                                                         │
│  Instance 0 ──→ BLAS A (Transform + Flags)              │
│  Instance 1 ──→ BLAS A (別Transform)                    │
│  Instance 2 ──→ BLAS B (Transform + Flags)              │
│  ...                                                    │
└─────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────┐
│ Bottom-Level Acceleration Structure (BLAS)              │
│                                                         │
│  Geometry 0: 三角形メッシュ（頂点 + インデックス）       │
│  Geometry 1: AABB（プロシージャルジオメトリ用）          │
│  ...                                                    │
└─────────────────────────────────────────────────────────┘
```

### シェーダーバインディングテーブル（SBT）

```
ヒットグループのインデックス計算:
  HitGroupIndex = InstanceContribution
                + (GeometryIndex × SlotsPerSegment)
                + RayContribution

SBT レイアウト:
  [RayGen] [Miss 0..N] [HitGroup 0..M] [Callable 0..K]

各エントリ:
  ShaderIdentifier (固定サイズ) + ローカルルートパラメータ
```

### レイトレーシングパイプライン

```
GPU 実行フロー:
  RayGen Shader
    → TraceRay()
    → 加速構造走査
    → ヒット検出
    → Closest-Hit / Any-Hit / Miss Shader 呼び出し
    → 呼び出し元に戻る
```

### 要件（Requirements）
- 2層加速構造（ジオメトリ用のBLAS + インスタンス階層のTLAS）
- 専用シェーダーパイプライン（RayGen, Closest-Hit, Any-Hit, Miss, Callable）
- シェーダーバインディング間接参照（ジオメトリ/マテリアル属性に基づく動的選択）
- スクラッチメモリ管理（構造構築用一時ワークスペース）

### 不変条件（Invariants）
- ジオメトリ変更時に加速構造は再構築/更新が必要
- インスタンストランスフォームはアフィンのみ（パースペクティブ不可）
- ペイロードサイズは事前宣言が必要（典型的デフォルト: 24バイト）
- BLAS はインスタンス間で共有可能（異なるトランスフォームで再利用）

### 設計判断（Design Decisions）

| 方式 | 説明 | 用途 |
|------|------|------|
| フルパイプライン | 専用シェーダーステージ使用 | 複雑なマテリアルシステム |
| インラインRT | コンピュートシェーダーからトレース | シンプルな用途、低オーバーヘッド |
| クラスタ化AS (CLAS) | 小ジオメトリクラスタのグループ化 | メモリオーバーヘッド削減 |

### ケイパビリティフラグ

| フラグ | 説明 |
|--------|------|
| SupportsRayTracing | AS構築 + RT専用シェーダー |
| SupportsRayTracingShaders | フルRTパイプライン |
| SupportsInlineRayTracing | コンピュートからのRT |
| SupportsRayTracingPSOAdditions | 既存RT PSOへのシェーダー追加 |
| SupportsRayTracingDispatchIndirect | 間接RTディスパッチ |
| SupportsAsyncBuildAccelerationStructure | 非同期AS構築 |

---

## 2. メッシュシェーダー

### 意図（Intent）
従来の頂点シェーダー + インプットアセンブラパイプラインを、
より柔軟なコンピュートベースのジオメトリ処理に置き換える。

### パイプライン構成

```
従来パイプライン:
  IA → VS → (GS) → Rasterizer → PS

メッシュシェーダーパイプライン:
  AS → MS → Rasterizer → PS

AS (Amplification Shader): メッシュレットのカリング/選択
MS (Mesh Shader): 頂点とプリミティブの生成
```

### ティア構成

| ティア | 機能 |
|--------|------|
| Tier 0 | Amplification + 基本メッシュシェーダー |
| Tier 1 | フルパイプライン + クリップ距離サポート |

### 要件（Requirements）
- メッシュレットベースのジオメトリ表現
- スレッドグループ単位の頂点/プリミティブ出力
- オプションの Amplification ステージによる事前カリング

### 不変条件（Invariants）
- メッシュシェーダー使用時は頂点宣言が null
- 各メッシュシェーダーグループは固定最大数の頂点/プリミティブを出力
- Tier 0 は基本機能のみ、Tier 1 でフル機能

---

## 3. ワークグラフ

### 意図（Intent）
GPUドリブンの動的ワーク生成を可能にし、
シェーダーがCPUラウンドトリップなしで追加ワークをスポーンする。

### ノードベース実行モデル

```
CPU: DispatchGraph(EntryNode, InitialRecordCount)

GPU:
  RootNode 実行
    → 出力レコード発行
    → スケジューラが依存ノードをキュー
    → ComputeNode 実行
    → 再帰的発行可能

ノード間通信: 型付きレコード（データ構造体）
```

### 要件（Requirements）
- ノードベースの実行（シェーダーがレコードを発行し下流ノードをトリガー）
- レコードベースの通信（ノード間で型付きデータ構造体を受け渡し）
- グラフトポロジ: 有向非巡回グラフ（DAG）
- エントリポイント: 初期ディスパッチパラメータを受け取るルートシェーダー

### ティア構成

| ティア | 機能 |
|--------|------|
| Tier 1.0 | コンピュートノードのみ |
| Tier 1.1 | グラフィクスノード対応（ジオメトリカリング→描画直結） |

### 不変条件（Invariants）
- ワーク生成は非同期かつ順序不定
- 兄弟ノード間の実行順序保証なし
- レコード用メモリは最悪ケースの展開に対応する割り当てが必要

### 設計判断（Design Decisions）

| 選択肢 | 理由 |
|--------|------|
| レコードベース（vs グローバルキュー） | 型安全性とキャッシュ局所性の向上 |
| ティア分割 | グラフィクスノード対応を段階的に導入 |

---

## 4. 可変レートシェーディング（VRS）

### 意図（Intent）
知覚的に重要度の低い画面領域のシェーディングコストを削減し、
ピクセルシェーダーをより粗い粒度で実行する。

### レート指定

```
利用可能レート:
  1×1（フル） | 1×2 | 2×1 | 2×2 | 2×4 | 4×2 | 4×4

3つのレートソース:
  ┌───────────┐    ┌───────────┐    ┌───────────┐
  │ パイプライン│    │ イメージ   │    │ プリミティブ│
  │ (per-draw) │    │ (per-tile) │    │ (per-prim) │
  └─────┬─────┘    └─────┬─────┘    └─────┬─────┘
        ↓                ↓                ↓
     Combiner 1       Combiner 2
        ↓                ↓
  ┌─────────────────────────────────┐
  │        最終レート               │
  └─────────────────────────────────┘
```

### コンバイナ操作

| 操作 | 説明 |
|------|------|
| Passthrough | 一方のソースのみ使用 |
| Override | 後段ソースで上書き |
| Min | 最も細かいレートを選択 |
| Max | 最も粗いレートを選択 |
| Sum | レートを合算（より粗く） |

### VRSイメージ

```
タイルベース表現:
  画面をタイル（8×8 〜 16×16 ピクセル）に分割
  各タイルにシェーディングレートを格納
  パレットエンコーディング: 離散列挙型レート値

Late Update 対応:
  フレーム中にVRSテクスチャを更新可能
  → GPU フィードバックに基づく動的調整
```

### 要件（Requirements）
- レート指定（1×1 ～ 4×4）
- 複数レートソースの合成ロジック
- イメージベースVRSのタイル表現

### 不変条件（Invariants）
- 実際のシェーディングレートはハードウェアサポート最大値にクランプ
- 深度/ステンシル書き込みは粗いシェーディングでもフル解像度で実行
- イメージベースVRSのタイルサイズはプラットフォーム依存（8×8 ～ 16×16）

### ケイパビリティフラグ

| フラグ | 説明 |
|--------|------|
| SupportsPipelineVRS | per-draw VRS |
| SupportsAttachmentVRS | イメージベースVRS |
| SupportsLargerVRSSizes | 2×4, 4×2, 4×4 |
| SupportsComplexVRSCombiners | Min/Max/Sum |
| SupportsLateVRSUpdate | フレーム中のVRS更新 |

---

## 5. エンハンスドバリア

### 意図（Intent）
最新GPUで不要なパイプラインストールを削減する、
きめ細かな同期制御を提供する。

### レガシーとの比較

```
レガシーモデル:
  リソース毎に単一のモノリシック状態
  遷移 = 状態A → 状態B（全情報が1つに結合）

エンハンスドモデル:
  3つの独立した関心事を分離:
  ┌──────────┐  ┌──────────┐  ┌──────────┐
  │ レイアウト │  │ アクセス   │  │ 同期      │
  │ (メモリ   │  │ (読み書き │  │ (パイプ   │
  │  配置)    │  │  意図)    │  │  ステージ) │
  └──────────┘  └──────────┘  └──────────┘

利点:
  レイアウトが変わらない場合、アクセスのみの遷移で済む
  → 不要なデコンプレッション/リコンプレッションを回避
```

### バリアバッチング

```
複数バリアを蓄積して一括発行:
  バッチ → Platform API (ResourceBarrier / vkCmdPipelineBarrier)

CVar による制御:
  バッチングの有効/無効切り替え
  デバッグ時にバリア毎の発行で問題特定
```

### 要件（Requirements）
- リソースレイアウトの明示的追跡
- アクセスタイプの指定（読み取り/書き込み意図）
- パイプラインステージの同期指定
- サブリソース粒度のバリアサポート

### 不変条件（Invariants）
- レイアウト遷移にはデコンプレッション/リコンプレッションが伴う場合がある
- 無関係なリソースのバリアは効率のためにバッチ可能
- スプリットバリア（begin/end）は依存コマンド間のパイプライニングを可能にする

### 設計判断（Design Decisions）
- ファクトリパターンでレガシー/エンハンスド実装を実行時選択
- GPUケイパビリティに基づく自動選択
- エンハンスドバリアは D3D12.1+ / Vulkan でネイティブサポート

---

## 6. シェーダーバンドル

### 意図（Intent）
多数の類似描画/ディスパッチ操作のリソースバインディングCPUオーバーヘッドを削減する。

### バンドル構成

```
Bundle {
  shaderBindings      // 共通バインドレスパラメータ
  argumentBuffer      // GPU読み取り可能な per-instance 引数バッファ
  dispatchArray       // ディスパッチ配列
  mode                // Compute / MeshPS / VertexPS
}

引数バッファレイアウト:
  [Record 0 | stride bytes] [Record 1 | stride bytes] [Record 2 | ...]

GPU実行:
  引数バッファ読み取り → 各ディスパッチ実行 → バッファオフセット増加
```

### モード別最小ストライド

| モード | 最小ストライド | ロード操作 |
|--------|-------------|----------|
| Compute (CS) | 12 bytes | Load3 |
| Mesh + Pixel (MSPS) | 4 bytes | Load |
| Vertex + Pixel (VSPS) | 16 bytes | Load4 |

### 要件（Requirements）
- バンドル定義（事前パッケージされたシェーダーバインディングとディスパッチパラメータ）
- 引数バッファ（GPU読み取り可能、ストライドアラインメント済み）
- 共有バインドレスパラメータ
- モード選択

### 不変条件（Invariants）
- 引数ストライドは最小要件を満たさなければならない
- ディスパッチ配列内のレコードインデックスが引数バッファエントリを決定
- バンドル作成はディスパッチサブミッションと分離されている

---

## 7. トランジェントリソースシステム

### 意図（Intent）
フレーム内の短寿命リソースのGPUメモリを再利用し、
ピークメモリ消費量を削減する。

### エイリアシングフロー

```
Acquire(ResourceA)  → 使用  → Discard(ResourceA)
  → フェンスシグナル → オーバーラップ確認 →
Acquire(ResourceB, alias ResourceA memory)

メモリ再利用条件:
  - ResourceA と ResourceB のライフタイムが重複しない
  - サイズ/アラインメントが互換
  - フェンスが ResourceA の使用完了を確認
```

### Acquire / Discard セマンティクス

| 操作 | 説明 |
|------|------|
| Acquire | リソースの所有権を取得（内容は未定義） |
| Discard | リソースの所有権を放棄（内容は無効化） |

### 割り当て戦略

| 戦略 | 説明 |
|------|------|
| Heap | 大ブロック割り当て |
| Page | きめ細かな割り当て |

### 作成モード

| モード | 説明 |
|--------|------|
| Inline | 常にインラインで作成 |
| Task | タスクにオフロード可能（アクセス前に Finish() 呼び出し必要） |

### 不変条件（Invariants）
- Discard 状態のリソースは内容が未定義
- Discard 後の最初の使用前に Acquire が必要
- ライフタイムが重複するリソースはサイズ互換でもエイリアシング不可

---

## 8. スパース/予約リソース

### 意図（Intent）
仮想アドレス空間のみを事前確保し、物理メモリを必要に応じてマップする。
巨大テクスチャやストリーミングのメモリ効率を向上させる。

### タイルベースメモリモデル

```
仮想アドレス空間（大）:
  ┌────┬────┬────┬────┬────┬────┬────┬────┐
  │ T0 │ T1 │ T2 │ T3 │ T4 │ T5 │ T6 │ T7 │  ← タイル
  └──┬─┴──┬─┴────┴──┬─┴────┴──┬─┴────┴────┘
     │    │         │         │
     ▼    ▼         ▼         ▼
  [物理] [物理]    [物理]    [物理]
  ページ  ページ    ページ    ページ

  T2, T4, T6, T7: 未マップ（物理メモリ不使用）
```

### タイルサイズ

```
標準タイルサイズ: 65536 bytes (64 KB)
  全プラットフォーム共通のマッピング可能最小物理メモリ単位
```

### ケイパビリティ

| フラグ | 説明 |
|--------|------|
| ReservedResources.Supported | スパースリソース対応 |
| ReservedResources.SupportsVolumeTextures | ボリュームテクスチャのスパース対応 |
| ReservedResources.TextureArrayMinimumMipDimension | テクスチャ配列の最小Mip次元 |

### 不変条件（Invariants）
- 未マップタイルへのアクセスは未定義動作（GPUページフォルト可能）
- マップ/アンマップ操作は明示的コマンド
- タイルサイズは全プラットフォームで 64KB

---

## 9. ケイパビリティシステム

### 意図（Intent）
プラットフォームサポートに基づいてレンダリングパスを有効/無効にする
ランタイム機能検出を提供する。

### ケイパビリティの種類

```
1. ブーリアンフラグ（GRHISupports*）
   → 機能の有無を示す二値

2. 数値リミット（GMax*）
   → テクスチャ最大サイズ、バッファサイズ等の量的制約

3. 構造化ケイパビリティ（FRHIGlobals サブ構造体）
   → 関連フラグのグループ化（RayTracing, VRS, ReservedResources等）

4. ワークアラウンドフラグ（GRHINeeds*）
   → プラットフォーム固有のバグ/制限のエンコード

5. フィーチャーレベル（SM5, SM6等）
   → 幅広いカテゴリ分類
```

### フィーチャーサポートレベル

| レベル | 説明 |
|--------|------|
| Unsupported | 機能非対応 |
| RuntimeDependent | ランタイム確認が必要 |
| RuntimeGuaranteed | 常に利用可能 |

### データフロー

```
RHI初期化
  → プラットフォーム照会
  → GRHIGlobals 設定
  → エンジンがフラグを読み取り
  → 互換レンダリングパスを選択
  → 互換コマンドを実行
```

### エディタプレビュー

```
TRHIGlobal<T> ラッパー:
  一部のリミットをエディタのモバイルプレビューモードで
  オーバーライド可能にする

  SetPreviewOverride(value)
  → エディタ内でモバイル制限をシミュレート
```

### 設計パターン

| パターン | 説明 |
|---------|------|
| ブーリアン + 数値ペアリング | 機能存在（bool）+ スケール（数値）の組み合わせ |
| ティアベース機能 | Tier 0/1 で段階的ハードウェア能力を表現 |
| ワークアラウンド隔離 | GRHINeeds* でバグをメインラインコードから分離 |
| デフォルト規約 | 高度機能は false/0、基本操作は true がデフォルト |
| ゼロ = 非サポート | 数値リミット 0 は機能利用不可を示す |

### 不変条件（Invariants）
- フラグはRHI起動時に初期化され、ランタイム中は一定
- 非サポート機能には適切なフォールバックパスが必要
- ケイパビリティ照会は低コスト（単純なグローバル変数読み取り）

---

## 10. ビデオデコード統合

### 意図（Intent）
ビデオ伸張を専用ハードウェアにオフロードし、GPU同期を維持する。

### デコードパイプライン

```
デコーダセッション作成
  → 圧縮ビットストリーム投入
  → デコーダがフレーム出力
  → レイアウト遷移（デコード最適→シェーダー読み取り可能）
  → テクスチャとしてバインド
  → レンダリング
```

### 要件（Requirements）
- グラフィクス/コンピュートキューとは独立したデコーダパイプライン
- デコーダ出力とレンダリング入力を調整するフェンス同期
- サポートコーデックと解像度のフォーマットネゴシエーション

### 不変条件（Invariants）
- デコード済みフレームはデコード最適レイアウトで生成（直接シェーダー読み取り不可）
- シェーダーサンプリング前にレイアウト遷移が必要
- デコーダセッションは重量オブジェクト（フレーム間で再利用）

---

## 11. ベンダー固有の最適化

### AMD HTile / FMask

| 機能 | 説明 |
|------|------|
| HTile | 深度バッファの階層メタデータ。タイル毎のmin/max深度でHi-Zカリング |
| FMask | MSAAターゲットの圧縮メタデータ。サンプル格納の最適化 |

```
使用手順:
  1. SupportsExplicitHTile を確認
  2. HTile メタデータプレーンでSRV作成
  3. タイル毎のmin/max深度を解釈してカスタムカリング

注意:
  - 深度書き込み時にHTileは自動更新
  - CPU/コンピュートによる深度変更後は手動再要約が必要
  - メタデータフォーマットはAMD固有（8×8タイル毎8バイト）
```

### NVIDIA Shader Execution Reordering (SER)

```
意図:
  シェーダー実行の並べ替えでレイ分散を低減し、
  キャッシュ局所性を向上させる。

使用:
  1. SupportsShaderExecutionReordering を確認
  2. SER対応のシェーダーコンパイルフラグを使用
  3. HLSL 内で ReorderThread() イントリンシックを注記

制約:
  - 並べ替えはアドバイザリ（GPUが無視する場合あり）
  - セマンティック変更なし（出力は決定的）
  - 性能向上はワークロード特性に依存
```

---

## 12. 実装優先度ガイダンス

### Tier 1: 必須

| 機能 | 説明 |
|------|------|
| 基本描画/ディスパッチ | Draw, Dispatch |
| テクスチャ/バッファ作成 | 基本リソースライフサイクル |
| パイプライン状態オブジェクト | Graphics PSO, Compute PSO |
| 同期 | フェンス、バリア |

### Tier 2: モダンベースライン

| 機能 | 説明 |
|------|------|
| 間接描画 | GPU駆動レンダリングの基礎 |
| UAV付きコンピュートシェーダー | 汎用GPU計算 |
| マルチスレッドサポート | CPU性能スケーリング |
| 基本リソース遷移 | 状態追跡と遷移 |

### Tier 3: 高度な機能

| 機能 | 説明 |
|------|------|
| レイトレーシング | インラインまたはフルパイプライン |
| メッシュシェーダー | コンピュートベースジオメトリ処理 |
| 可変レートシェーディング | 適応的シェーディング品質 |
| 非同期コンピュート | グラフィクスとコンピュートの並列実行 |

### Tier 4: 最先端

| 機能 | 説明 |
|------|------|
| ワークグラフ | GPU駆動シェーダーディスパッチツリー |
| シェーダーバンドル | バッチ化されたシェーダー呼び出し |
| エンハンスドバリア | きめ細かな同期制御 |
| マルチGPU (AFR/SFR) | 複数GPU協調動作 |
