# Hybrid Component パターン

## GameObjectとECSの二重管理を解消する設計

---

## 1. 解決する問題

### 従来の二重管理問題

ゲーム開発において、GameObjectベースのOOP設計とECS設計を併用しようとすると、同じデータが2箇所に存在する「二重管理」が発生しやすい。

```
┌─────────────────────────────────────────────────────────────────┐
│                    従来の問題（二重管理）                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────┐      ┌─────────────────────┐          │
│  │  GameObject (Player)│      │  ECS                │          │
│  │                     │      │                     │          │
│  │  position (x, y)    │←同期→│  Position[]         │          │
│  │  health             │←同期→│  Health[]           │          │
│  │  velocity           │←同期→│  Velocity[]         │          │
│  │                     │      │                     │          │
│  └─────────────────────┘      └─────────────────────┘          │
│                                                                 │
│  問題点:                                                        │
│    - 同じデータが2箇所に存在                                   │
│    - 変更のたびに同期が必要                                    │
│    - 同期漏れでバグ発生                                        │
│    - メモリの無駄                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 単純な解決策の限界

「全部ECSにする」「全部OOPにする」という単純な解決策では、それぞれの良さが失われる。

```
┌─────────────────────────────────────────────────────────────────┐
│                    単純な解決策の問題                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ■ 全部ECSにする場合                                           │
│                                                                 │
│    ✓ 二重管理は解消                                            │
│    ✓ 大量処理は効率的                                          │
│    ✗ 複雑なロジック（AI、アニメ）が書きにくい                 │
│    ✗ 状態マシンやビヘイビアツリーの表現が困難                 │
│                                                                 │
│  ■ 全部OOPにする場合                                           │
│                                                                 │
│    ✓ 二重管理は解消                                            │
│    ✓ 複雑なロジックが書きやすい                               │
│    ✗ 大量Entityの処理が遅い                                   │
│    ✗ キャッシュ効率が悪い                                      │
│    ✗ 並列化が困難                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. Hybrid Componentパターンの核心

### 基本アイデア

コンポーネントの特性に応じて、ECSで管理するかOOPで管理するかを選択する。両者は相互参照で連携し、データの重複は発生しない。

```
┌─────────────────────────────────────────────────────────────────┐
│                  Hybrid Component の基本構造                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1つのEntity（例: Player）                                    │
│                                                                 │
│   ┌───────────────────────────────────────────────────────┐    │
│   │  GameObject                                           │    │
│   │  ┌─────────────────────────────────────────────────┐  │    │
│   │  │  OOP Components（複雑ロジック向き）             │  │    │
│   │  │                                                 │  │    │
│   │  │   - Animation（ブレンド、状態マシン）          │  │    │
│   │  │   - AIController（行動ツリー、意思決定）       │  │    │
│   │  │   - Script（ユーザー定義ロジック）             │  │    │
│   │  │                                                 │  │    │
│   │  └─────────────────────────────────────────────────┘  │    │
│   │                                                       │    │
│   │  EntityID ────────────────┐                          │    │
│   └───────────────────────────┼───────────────────────────┘    │
│                               │                                 │
│                               │ 参照                            │
│                               ▼                                 │
│   ┌───────────────────────────────────────────────────────┐    │
│   │  ECS                                                  │    │
│   │  ┌─────────────────────────────────────────────────┐  │    │
│   │  │  ECS Components（大量処理向き）                 │  │    │
│   │  │                                                 │  │    │
│   │  │   - Position[]（位置）                         │  │    │
│   │  │   - Velocity[]（速度）                         │  │    │
│   │  │   - Collider[]（当たり判定）                   │  │    │
│   │  │   - GameObjectRef[]（逆参照用）                │  │    │
│   │  │                                                 │  │    │
│   │  └─────────────────────────────────────────────────┘  │    │
│   └───────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### なぜ二重管理にならないか

各コンポーネントは「ECSかOOPのどちらか一方」にしか存在しない。データの重複がないため、同期も不要。

```
┌─────────────────────────────────────────────────────────────────┐
│                    データの所在（重複なし）                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  コンポーネント        所在           理由                      │
│  ─────────────────────────────────────────────────────────     │
│  Position          →  ECS のみ      大量処理、物理演算         │
│  Velocity          →  ECS のみ      大量処理、物理演算         │
│  Collider          →  ECS のみ      当たり判定の一括処理       │
│  Animation         →  OOP のみ      状態マシン、複雑ロジック   │
│  AIController      →  OOP のみ      行動ツリー、意思決定       │
│  Script            →  OOP のみ      ユーザー定義、柔軟性       │
│                                                                 │
│  → 各コンポーネントは1箇所にしか存在しない                     │
│  → 二重管理は発生しない                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. コンポーネントの分類基準

### ECS Componentに向いているもの

```
┌─────────────────────────────────────────────────────────────────┐
│                  ECS Component の特徴                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ■ 選定基準                                                    │
│                                                                 │
│    - 大量のEntityに対して毎フレーム処理する                    │
│    - データが単純（数値、フラグ、ベクトル等）                  │
│    - 処理が均一（全Entityに同じ処理を適用）                    │
│    - 他のComponentとの依存が少ない                             │
│                                                                 │
│  ■ 具体例                                                      │
│                                                                 │
│    Position       位置座標                                     │
│    Velocity       速度ベクトル                                 │
│    Rotation       回転                                         │
│    Scale          スケール                                     │
│    Collider       当たり判定形状                               │
│    RigidBody      物理パラメータ（質量、摩擦等）               │
│    Health         HP（単純な数値）                             │
│    Team           所属チーム（フラグ）                         │
│    Lifetime       生存時間（パーティクル等）                   │
│                                                                 │
│  ■ 処理例                                                      │
│                                                                 │
│    MovementSystem     全Entityの位置を速度で更新               │
│    CollisionSystem    全ペアの当たり判定をチェック             │
│    PhysicsSystem      物理演算を一括処理                       │
│    LifetimeSystem     寿命切れEntityの削除                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### OOP Componentに向いているもの

```
┌─────────────────────────────────────────────────────────────────┐
│                  OOP Component の特徴                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ■ 選定基準                                                    │
│                                                                 │
│    - 複雑な内部状態を持つ                                      │
│    - 状態マシンやツリー構造がある                              │
│    - 処理が個体ごとに大きく異なる                              │
│    - 継承やポリモーフィズムが有効                              │
│    - 外部ライブラリとの連携が必要                              │
│                                                                 │
│  ■ 具体例                                                      │
│                                                                 │
│    Animation       アニメーション状態マシン、ブレンド          │
│    AIController    行動ツリー、ステートマシン                  │
│    Script          ユーザー定義スクリプト                      │
│    DialogSystem    会話ツリー、選択肢管理                      │
│    InventoryUI     インベントリの表示・操作                    │
│    AudioSource     サウンド再生（外部ライブラリ連携）          │
│    ParticleEmitter パーティクル生成ロジック                    │
│    NetworkSync     ネットワーク同期ロジック                    │
│                                                                 │
│  ■ 特徴                                                        │
│                                                                 │
│    - クラスとして実装                                          │
│    - 内部状態をカプセル化                                      │
│    - メソッドで振る舞いを定義                                  │
│    - 継承で派生クラスを作成可能                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 相互参照の仕組み

### OOP → ECS の参照

OOP ComponentからECS Componentにアクセスする場合、GameObjectが持つEntityIDを使う。

```
┌─────────────────────────────────────────────────────────────────┐
│                    OOP → ECS の参照                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  GameObject (Player)                                    │   │
│  │                                                         │   │
│  │  EntityID entity ──────────┐                           │   │
│  │                            │                           │   │
│  │  Animation animation       │                           │   │
│  │    │                       │                           │   │
│  │    └─ Update() {           │                           │   │
│  │         現在位置が欲しい   │                           │   │
│  │              │             │                           │   │
│  │              ▼             │                           │   │
│  │         ecs.get<Position>(entity)                      │   │
│  │       }                    │                           │   │
│  │                            │                           │   │
│  └────────────────────────────┼─────────────────────────────┘   │
│                               │                                 │
│                               ▼                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  ECS                                                    │   │
│  │                                                         │   │
│  │  Position[entity] ← ここからデータを取得               │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ポイント:                                                      │
│    - GameObjectがEntityIDを持っている                          │
│    - OOP ComponentはそのIDでECSにアクセス                      │
│    - ルックアップが発生するが、頻度が低ければ許容範囲          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ECS → OOP の参照（逆参照）

ECS SystemからOOP Componentにアクセスする場合、専用の参照用Componentを使う。

```
┌─────────────────────────────────────────────────────────────────┐
│                    ECS → OOP の参照（逆参照）                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  ECS                                                    │   │
│  │                                                         │   │
│  │  Position[entity]                                       │   │
│  │  Collider[entity]                                       │   │
│  │  GameObjectRef[entity] ─────┐                          │   │
│  │                             │                          │   │
│  │  CollisionSystem:           │                          │   │
│  │    for (entity : entities)  │                          │   │
│  │      if (衝突した)          │                          │   │
│  │        │                    │                          │   │
│  │        │  逆参照で取得      │                          │   │
│  │        │         │          │                          │   │
│  │        ▼         ▼          │                          │   │
│  │      GameObjectRef[entity].ptr                         │   │
│  │              │              │                          │   │
│  └──────────────┼──────────────┼───────────────────────────┘   │
│                 │              │                               │
│                 │              │ ポインタ                      │
│                 ▼              ▼                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  GameObject (Player)                                    │   │
│  │                                                         │   │
│  │  Animation animation ← PlayHitAnimation() を呼べる     │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ポイント:                                                      │
│    - GameObjectRef はポインタを1つ持つだけ                    │
│    - 衝突検知（大量処理）はECS効率で実行                       │
│    - 衝突反応（少数）でのみOOPを呼び出す                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 典型的な処理フロー

### 例: 当たり判定と衝突反応

```
┌─────────────────────────────────────────────────────────────────┐
│                  当たり判定の処理フロー                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Phase 1: Broadphase（粗いチェック）                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  ECS System                                             │   │
│  │                                                         │   │
│  │  for (全Entity)     ← 大量処理、ECS効率               │   │
│  │    AABB重なりチェック                                   │   │
│  │    → 候補ペアリストに追加                              │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                             │                                   │
│                             ▼                                   │
│  Phase 2: Narrowphase（詳細チェック）                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  ECS System                                             │   │
│  │                                                         │   │
│  │  for (候補ペア)     ← 中量処理、ECS効率               │   │
│  │    詳細な衝突判定                                       │   │
│  │    → 衝突ペアリストに追加                              │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                             │                                   │
│                             ▼                                   │
│  Phase 3: Response（衝突反応）                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  ECS → OOP 呼び出し                                    │   │
│  │                                                         │   │
│  │  for (衝突ペア)     ← 少数、OOP呼び出しOK             │   │
│  │    playerObj = GameObjectRef[entity].ptr                │   │
│  │    playerObj->animation.PlayHitAnimation()              │   │
│  │    playerObj->script.OnCollision(other)                 │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  結果:                                                          │
│    - 大量処理（Phase 1, 2）はECS効率を維持                     │
│    - 複雑な反応（Phase 3）はOOPで柔軟に記述                    │
│    - 両方の良さを同時に活用                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 例: AI更新と移動処理

```
┌─────────────────────────────────────────────────────────────────┐
│                    AI更新と移動の処理フロー                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Step 1: AI意思決定（OOP）                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  GameObject.AIController                                │   │
│  │                                                         │   │
│  │  Update() {                                             │   │
│  │    // 行動ツリーを評価（複雑なロジック）               │   │
│  │    // 現在位置を取得（ECSから）                        │   │
│  │    pos = ecs.get<Position>(entity)                      │   │
│  │                                                         │   │
│  │    // 移動先を決定                                      │   │
│  │    target = DecideTarget()                              │   │
│  │                                                         │   │
│  │    // 速度をECSに書き込む                              │   │
│  │    ecs.get<Velocity>(entity) = CalculateVelocity()      │   │
│  │  }                                                      │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                             │                                   │
│                             │ Velocityを設定                    │
│                             ▼                                   │
│  Step 2: 移動処理（ECS）                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  MovementSystem                                         │   │
│  │                                                         │   │
│  │  for (全Entity)     ← 大量処理、ECS効率               │   │
│  │    Position += Velocity * dt                            │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  結果:                                                          │
│    - 複雑な意思決定はOOPで記述                                 │
│    - 実際の移動計算はECSで効率的に一括処理                     │
│    - 役割分担が明確                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 生成と破棄

### Factoryによる一元管理

GameObjectとEntityの生成・破棄を同期させるため、Factoryパターンを使用する。

```
┌─────────────────────────────────────────────────────────────────┐
│                  生成・破棄の一元管理                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  EntityFactory                                          │   │
│  │                                                         │   │
│  │  CreatePlayer():                                        │   │
│  │    1. ECSでEntity生成                                   │   │
│  │    2. ECS Componentを追加                               │   │
│  │       - Position                                        │   │
│  │       - Velocity                                        │   │
│  │       - Collider                                        │   │
│  │       - GameObjectRef                                   │   │
│  │    3. GameObjectを生成                                  │   │
│  │       - Animation                                       │   │
│  │       - AIController                                    │   │
│  │    4. 相互参照を設定                                    │   │
│  │       - GameObject.entityId = entity                    │   │
│  │       - GameObjectRef.ptr = gameObject                  │   │
│  │    5. GameObjectを返す                                  │   │
│  │                                                         │   │
│  │  ─────────────────────────────────────────────────     │   │
│  │                                                         │   │
│  │  Destroy(player):                                       │   │
│  │    1. EntityIDを取得                                    │   │
│  │    2. ECS Componentを削除                               │   │
│  │    3. Entity破棄                                        │   │
│  │    4. GameObject破棄                                    │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ポイント:                                                      │
│    - 生成・破棄を1箇所で管理                                   │
│    - 相互参照の設定漏れを防ぐ                                  │
│    - 破棄時の参照切れを防ぐ                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────┐
│                Hybrid Component パターン 全体像                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    EntityFactory                        │   │
│  │                                                         │   │
│  │   Create / Destroy を一元管理                          │   │
│  └───────────────────────┬─────────────────────────────────┘   │
│                          │                                      │
│          ┌───────────────┴───────────────┐                     │
│          ▼                               ▼                     │
│  ┌─────────────────────┐      ┌─────────────────────────┐     │
│  │                     │      │                         │     │
│  │  GameObject層       │      │  ECS層                  │     │
│  │  (OOP Components)   │      │  (ECS Components)       │     │
│  │                     │◄────►│                         │     │
│  │  ┌───────────────┐  │      │  ┌─────────────────┐    │     │
│  │  │ Animation     │  │      │  │ Position[]      │    │     │
│  │  │ AIController  │  │      │  │ Velocity[]      │    │     │
│  │  │ Script        │  │      │  │ Collider[]      │    │     │
│  │  │ DialogSystem  │  │      │  │ Health[]        │    │     │
│  │  └───────────────┘  │      │  │ GameObjectRef[] │    │     │
│  │                     │      │  └─────────────────┘    │     │
│  │  EntityID ──────────┼──────┼──►                      │     │
│  │                     │      │                         │     │
│  └─────────────────────┘      └─────────────────────────┘     │
│                                          │                     │
│                                          ▼                     │
│                               ┌─────────────────────────┐     │
│                               │  ECS Systems            │     │
│                               │                         │     │
│                               │  - MovementSystem       │     │
│                               │  - CollisionSystem      │     │
│                               │  - PhysicsSystem        │     │
│                               │  - RenderSystem         │     │
│                               │                         │     │
│                               └─────────────────────────┘     │
│                                                                 │
│  データの流れ:                                                 │
│    OOP → ECS: EntityID経由でアクセス                          │
│    ECS → OOP: GameObjectRef経由でアクセス                     │
│                                                                 │
│  処理の流れ:                                                   │
│    大量処理: ECS System が直接処理                            │
│    複雑処理: OOP Component のメソッドを呼び出し               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. 評価

### ECSの良さ

| 項目 | 評価 | 理由 |
|------|:----:|------|
| キャッシュ効率 | ◎ | ECS Componentは連続配置 |
| 並列化 | ◎ | Systemは並列実行可能 |
| 一括処理 | ◎ | 大量Entityを効率的に処理 |

### OOPの良さ

| 項目 | 評価 | 理由 |
|------|:----:|------|
| データ所有 | ◎ | OOP ComponentはGameObjectが本当に所有 |
| 複雑ロジック | ◎ | 状態マシン、ツリー構造を自然に記述 |
| カプセル化 | ◎ | 内部状態を隠蔽可能 |
| 継承 | ◎ | OOP Componentは継承可能 |

### 二重管理

| 項目 | 評価 | 理由 |
|------|:----:|------|
| データ重複 | なし | 各Componentはどちらか一方にのみ存在 |
| 同期処理 | 不要 | 参照でアクセスするため常に最新 |

---

## 9. 設計上の注意点

### コンポーネントの分類

新しいComponentを追加する際は、特性に応じてECS/OOPを選択する。

```
┌─────────────────────────────────────────────────────────────────┐
│                    分類の判断フロー                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  新しいComponentを追加したい                                   │
│         │                                                       │
│         ▼                                                       │
│  ┌─────────────────────────────────────┐                       │
│  │ 大量のEntityに毎フレーム処理する？ │                       │
│  └───────────────┬─────────────────────┘                       │
│          Yes     │     No                                       │
│           │      │      │                                       │
│           ▼      │      ▼                                       │
│  ┌─────────────┐ │ ┌─────────────────────────────────┐         │
│  │ データは    │ │ │ 複雑な内部状態がある？         │         │
│  │ 単純？      │ │ └───────────────┬─────────────────┘         │
│  └──────┬──────┘ │         Yes     │     No                     │
│     Yes │  No    │          │      │      │                     │
│      │  │   │    │          ▼      │      ▼                     │
│      ▼  │   ▼    │    ┌─────────┐  │  ┌─────────┐              │
│ ┌─────┐ │┌─────┐ │    │  OOP    │  │  │ どちらで│              │
│ │ ECS │ ││ OOP │ │    │         │  │  │ も良い  │              │
│ └─────┘ │└─────┘ │    └─────────┘  │  └─────────┘              │
│         │        │                 │                            │
│         └────────┴─────────────────┘                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 循環参照の回避

OOP → ECS → OOP の循環呼び出しに注意する。

```
┌─────────────────────────────────────────────────────────────────┐
│                    循環参照の注意                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  危険なパターン:                                               │
│                                                                 │
│    AIController.Update()                                       │
│      → ecs.get<Position>()                                    │
│      → CollisionSystem発火（仮に同期実行の場合）              │
│        → GameObjectRef.OnCollision()                          │
│          → AIController.HandleCollision()                     │
│            → 無限ループの可能性                               │
│                                                                 │
│  回避策:                                                        │
│                                                                 │
│    1. System間の実行順序を明確に定義                           │
│    2. イベントキューで遅延実行                                 │
│    3. フラグで再入を防止                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 10. 結論

**Hybrid Componentパターン**は、コンポーネントの特性に応じてECSとOOPを使い分けることで、二重管理を発生させずに両方の良さを取る設計である。

**核心:**
- データは重複しない（各Componentはどちらか一方に存在）
- 相互参照で連携（EntityID と GameObjectRef）
- 用途に応じた使い分け（大量処理はECS、複雑ロジックはOOP）

**適用場面:**
- 大規模なゲームで、物理・当たり判定はECS効率が必要
- AI、アニメーション、スクリプトは複雑なロジックが必要
- 既存のOOPベースのコードとECSを共存させたい

このパターンにより、「全部ECS」「全部OOP」の二択ではなく、コンポーネント単位で最適な選択が可能になる。
