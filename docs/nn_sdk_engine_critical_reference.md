# NS SDK エンジン必須ユーティリティ リファレンス

ゲームエンジン構築に必須のOS層、スレッディング、メモリ管理、非同期処理ユーティリティの詳細解説。

---

## 目次

1. [Fiber - 軽量コルーチン](#1-fiber---軽量コルーチン)
2. [Thread同期プリミティブ](#2-thread同期プリミティブ)
3. [Tick - 高精度時間計測](#3-tick---高精度時間計測)
4. [MemoryFence - メモリバリア](#4-memoryfence---メモリバリア)
5. [UnitHeap - 固定サイズブロックアロケータ](#5-unitheap---固定サイズブロックアロケータ)
6. [ExpHeap - 汎用ヒープ](#6-expheap---汎用ヒープ)
7. [ThreadPool & Executor - 非同期タスク基盤](#7-threadpool--executor---非同期タスク基盤)
8. [ジョブシステム設計パターン](#8-ジョブシステム設計パターン)

---

## 1. Fiber - 軽量コルーチン

### 概要

ユーザーモードで動作する軽量実行単位。OSスレッドと異なり、明示的な`SwitchToFiber()`呼び出しでのみ切り替わる協調的マルチタスク。

### Thread vs Fiber

```
┌─────────────────────────────────────────────────────────────────┐
│ OS Thread                                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                        │
│  │Thread 0 │  │Thread 1 │  │Thread 2 │                        │
│  │         │  │         │  │         │                        │
│  │ Stack   │  │ Stack   │  │ Stack   │  ← 各スレッド1MB+      │
│  │ TLS     │  │ TLS     │  │ TLS     │  ← カーネル管理       │
│  │ Context │  │ Context │  │ Context │                        │
│  └────┬────┘  └────┬────┘  └────┬────┘                        │
│       │            │            │                              │
│       └────────────┴────────────┘                              │
│                    │                                           │
│              OS Scheduler                                      │
│         (プリエンプティブ切り替え)                              │
│                                                                 │
│  特徴:                                                          │
│  - カーネルモード遷移が必要                                     │
│  - コンテキストスイッチ: 数千サイクル                           │
│  - スレッド数に実用的上限あり（数百程度）                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ Fiber (ユーザーモードコルーチン)                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Thread 0 上で動作:                                             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐       │   │
│  │  │Fiber A │  │Fiber B │  │Fiber C │  │Fiber D │  ...   │   │
│  │  │ Stack  │  │ Stack  │  │ Stack  │  │ Stack  │       │   │
│  │  │ (小)   │  │ (小)   │  │ (小)   │  │ (小)   │       │   │
│  │  └───┬────┘  └───┬────┘  └───┬────┘  └───┬────┘       │   │
│  │      │           │           │           │              │   │
│  │      └─────┬─────┴─────┬─────┴─────┬─────┘              │   │
│  │            │           │           │                    │   │
│  │      SwitchToFiber() - 明示的切り替え                   │   │
│  │            │                                            │   │
│  │  ┌─────────▼─────────┐                                  │   │
│  │  │   Thread Context  │ ← 共有（TLS, 優先度など）       │   │
│  │  └───────────────────┘                                  │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  特徴:                                                          │
│  - ユーザーモードのみ（カーネル遷移なし）                       │
│  - コンテキストスイッチ: 数十サイクル                           │
│  - 数千〜数万のFiberが実用的                                    │
│  - スタックサイズを小さく設定可能                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Fiber API

```
┌─────────────────────────────────────────────────────────────────┐
│ Fiber ライフサイクル                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  状態遷移:                                                      │
│                                                                 │
│  NotInitialized ──► Ready ──► Running ──► Ready ──► ...        │
│        │              │          │          │                   │
│        │              │          │          │                   │
│        │              │          ▼          │                   │
│        │              │      Completed ◄────┘                   │
│        │              │          │                              │
│        └──────────────┴──────────┴─► NotInitialized             │
│                     (FinalizeFiber)                             │
│                                                                 │
│  API:                                                           │
│  ─────                                                          │
│  // 初期化                                                      │
│  void InitializeFiber(                                          │
│      FiberType* fiber,        // Fiberオブジェクト              │
│      FiberFunction function,  // エントリポイント               │
│      void* argument,          // 引数                           │
│      void* stack,             // スタック領域                   │
│      size_t stackSize,        // スタックサイズ                 │
│      int fiberFlag            // フラグ                         │
│  );                                                             │
│                                                                 │
│  // 切り替え                                                    │
│  void SwitchToFiber(FiberType* fiber);                          │
│  // fiber=NULL で元のスレッドに復帰                             │
│                                                                 │
│  // 現在のFiber取得                                             │
│  FiberType* GetCurrentFiber();                                  │
│  // スレッド実行中はNULL                                        │
│                                                                 │
│  // 破棄                                                        │
│  void FinalizeFiber(FiberType* fiber);                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### FiberFlag オプション

```
┌─────────────────────────────────────────────────────────────────┐
│ スタックガード設定                                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  FiberFlag_NoStackGuard なし（デフォルト）:                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ ████ Guard Page ████ │   Fiber Stack   │ ████ Guard ████│   │
│  │     (アクセス不可)    │   (ミラー領域)   │   (アクセス不可)│   │
│  └─────────────────────────────────────────────────────────┘   │
│  - スタックオーバーフローを即座に検出                           │
│  - GuardedStackAlignment でアラインメント必須                   │
│                                                                 │
│  FiberFlag_NoStackGuard あり:                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │               Fiber Stack (指定領域そのまま)             │   │
│  └─────────────────────────────────────────────────────────┘   │
│  - ガードページなし（オーバーフロー検出不可）                   │
│  - FiberStackAlignment でアラインメント                         │
│  - メモリ節約、大量Fiber向け                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ジョブシステムでのFiber活用

```
┌─────────────────────────────────────────────────────────────────┐
│ Fiber-based Job System                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Worker Thread 0:                                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │  Job A (Fiber)     Job B (Fiber)     Job C (Fiber)     │   │
│  │  ┌───────────┐     ┌───────────┐     ┌───────────┐     │   │
│  │  │ 処理開始  │     │           │     │           │     │   │
│  │  │    ↓     │     │           │     │           │     │   │
│  │  │ I/O待ち  │────►│ 処理開始  │     │           │     │   │
│  │  │ (中断)   │     │    ↓     │     │           │     │   │
│  │  │          │     │ 依存待ち │────►│ 処理開始  │     │   │
│  │  │          │     │ (中断)   │     │    ↓     │     │   │
│  │  │          │◄────│          │     │ 完了     │     │   │
│  │  │ 再開     │     │          │     └───────────┘     │   │
│  │  │    ↓     │     │          │                       │   │
│  │  │ 完了     │     │          │                       │   │
│  │  └───────────┘     └───────────┘                       │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  利点:                                                          │
│  - ジョブが待機状態になっても他のジョブを即座に実行             │
│  - スレッドをブロックせずに依存関係を表現                       │
│  - 数千のジョブを少数のスレッドで効率的に処理                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. Thread同期プリミティブ

### 同期プリミティブ一覧

```
┌─────────────────────────────────────────────────────────────────┐
│ 同期プリミティブの選択ガイド                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌────────────────────┬──────────────────────────────────────┐ │
│  │ プリミティブ        │ 用途                                 │ │
│  ├────────────────────┼──────────────────────────────────────┤ │
│  │ Mutex              │ 汎用排他制御                         │ │
│  │ BusyMutex          │ 短いクリティカルセクション           │ │
│  │ ReaderWriterLock   │ 読み取り多数のデータ保護             │ │
│  │ Semaphore          │ リソースプール、Producer-Consumer    │ │
│  │ LightSemaphore     │ 高頻度セマフォ操作                   │ │
│  │ ConditionVariable  │ 状態変更の待機                       │ │
│  │ Event              │ 単発/繰り返しシグナル                │ │
│  │ LightEvent         │ 高頻度イベント                       │ │
│  │ Barrier            │ 複数スレッドの同期点                 │ │
│  │ MessageQueue       │ スレッド間メッセージ                 │ │
│  └────────────────────┴──────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Barrier - フレーム同期

```
┌─────────────────────────────────────────────────────────────────┐
│ Barrier による複数スレッドの同期                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  InitializeBarrier(&barrier, 4);  // 4スレッドで同期           │
│                                                                 │
│  Thread 0    Thread 1    Thread 2    Thread 3                  │
│     │           │           │           │                      │
│     │ 処理      │ 処理      │ 処理      │ 処理                │
│     ▼           ▼           ▼           ▼                      │
│  AwaitBarrier AwaitBarrier AwaitBarrier AwaitBarrier           │
│     │           │           │           │                      │
│     ├───────────┴───────────┴───────────┤                      │
│     │         全員到着まで待機          │                      │
│     ├───────────┬───────────┬───────────┤                      │
│     │           │           │           │                      │
│     ▼           ▼           ▼           ▼                      │
│   次フレーム  次フレーム  次フレーム  次フレーム               │
│                                                                 │
│  用途:                                                          │
│  - フレーム境界での全ワーカー同期                               │
│  - 物理→レンダリングのフェーズ切り替え                         │
│  - ダブルバッファ切り替えタイミング                             │
│                                                                 │
│  API:                                                           │
│  InitializeBarrier(barrier, numThreads)  // 初期化             │
│  AwaitBarrier(barrier)                   // 待ち合わせ          │
│  FinalizeBarrier(barrier)                // 破棄               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Mutex vs BusyMutex

```
┌─────────────────────────────────────────────────────────────────┐
│ Mutex（通常）                                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Thread A              Thread B                                 │
│     │                     │                                     │
│     │ LockMutex()         │                                     │
│     ├─────────────────────│                                     │
│     │ クリティカル        │ LockMutex()                        │
│     │ セクション          │    │                               │
│     │ (長い処理)          │    ▼                               │
│     │                     │ [スリープ] ← OSがスケジュールアウト│
│     │ UnlockMutex()       │    │                               │
│     ├─────────────────────│    │                               │
│     │                     │ [ウェイクアップ]                   │
│     │                     ├────┘                               │
│     ▼                     ▼                                     │
│                                                                 │
│  特徴: スリープするためCPUを解放、長い待機向け                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ BusyMutex（スピンロック）                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Thread A              Thread B                                 │
│     │                     │                                     │
│     │ LockBusyMutex()     │                                     │
│     ├─────────────────────│                                     │
│     │ クリティカル        │ LockBusyMutex()                    │
│     │ セクション          │    │                               │
│     │ (短い処理)          │    ▼                               │
│     │                     │ [スピン] ← CPUサイクル消費        │
│     │ UnlockBusyMutex()   │ [スピン]   しながら待機            │
│     ├─────────────────────│ [スピン]                           │
│     │                     ├────┘ (即座にロック取得)            │
│     ▼                     ▼                                     │
│                                                                 │
│  特徴: スリープしないため即座に再開、短い待機向け              │
│        ただし待機中もCPUを消費                                  │
│                                                                 │
│  使い分け:                                                      │
│  ┌────────────────┬────────────────────────────────────────┐   │
│  │ BusyMutex推奨  │ クリティカルセクション < 数百サイクル  │   │
│  │ Mutex推奨      │ クリティカルセクション > 数百サイクル  │   │
│  │                │ または待機時間が長い/不定              │   │
│  └────────────────┴────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ReaderWriterLock

```
┌─────────────────────────────────────────────────────────────────┐
│ ReaderWriterLock - 読み書きロック                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  複数Reader同時アクセス可能:                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                     共有データ                           │   │
│  │  Reader 0 ──読み取り──►│                                │   │
│  │  Reader 1 ──読み取り──►│◄──読み取り── Reader 2         │   │
│  │  Reader 3 ──読み取り──►│                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Writer排他:                                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                     共有データ                           │   │
│  │  Reader 0 ──[待機]                                      │   │
│  │  Reader 1 ──[待機]    │◄──書き込み── Writer            │   │
│  │  Reader 2 ──[待機]                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  用途:                                                          │
│  - アセットキャッシュ（読み取り多数、更新稀）                   │
│  - ゲーム状態のクエリ（システムは読み取り、更新は限定的）       │
│  - ECSのWorld（クエリは読み取り、構造変更は書き込み）           │
│                                                                 │
│  API:                                                           │
│  AcquireReadLock(rwlock)      // 読み取りロック取得            │
│  ReleaseReadLock(rwlock)      // 読み取りロック解放            │
│  AcquireWriteLock(rwlock)     // 書き込みロック取得            │
│  ReleaseWriteLock(rwlock)     // 書き込みロック解放            │
│  TryAcquireReadLock(rwlock)   // 試行（非ブロック）            │
│  TryAcquireWriteLock(rwlock)  // 試行（非ブロック）            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. Tick - 高精度時間計測

### 概要

システムの高精度タイマーカウンタ。フレーム時間計測、プロファイリング、デルタタイム計算に使用。

### Tick API

```
┌─────────────────────────────────────────────────────────────────┐
│ Tick 計測と変換                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // 現在のティック取得                                          │
│  Tick tick = GetSystemTick();                                   │
│                                                                 │
│  // 順序保証付きティック取得（プロファイリング向け）            │
│  Tick orderedTick = GetSystemTickOrdered();                     │
│  // 前後の命令・メモリ操作との順序が保証される                  │
│                                                                 │
│  // ティック周波数（1秒あたりのカウント数）                     │
│  int64_t freq = GetSystemTickFrequency();                       │
│                                                                 │
│  // TimeSpanとの相互変換                                        │
│  TimeSpan ts = ConvertToTimeSpan(tick);                         │
│  Tick t = ConvertToTick(timeSpan);                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### フレーム時間計測パターン

```
┌─────────────────────────────────────────────────────────────────┐
│ デルタタイム計算                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Tick lastTick = GetSystemTick();                               │
│                                                                 │
│  while (running) {                                              │
│      Tick currentTick = GetSystemTick();                        │
│      Tick deltaTick = currentTick - lastTick;                   │
│      lastTick = currentTick;                                    │
│                                                                 │
│      TimeSpan deltaTime = ConvertToTimeSpan(deltaTick);         │
│      float dt = deltaTime.GetSeconds();  // 秒単位              │
│                                                                 │
│      Update(dt);                                                │
│      Render();                                                  │
│  }                                                              │
│                                                                 │
│  タイムライン:                                                  │
│  ┌─────────┬─────────┬─────────┬─────────┐                    │
│  │ Frame 0 │ Frame 1 │ Frame 2 │ Frame 3 │                    │
│  └────┬────┴────┬────┴────┬────┴────┬────┘                    │
│       │         │         │         │                          │
│    lastTick  currentTick                                       │
│       │◄────────►│                                             │
│         deltaTick                                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### GetSystemTick vs GetSystemTickOrdered

```
┌─────────────────────────────────────────────────────────────────┐
│ 順序保証の違い                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  GetSystemTick() - 順序保証なし:                                │
│  ────────────────────────────────                               │
│  CPUのアウトオブオーダー実行により、ティック取得と              │
│  前後の命令の実行順序が入れ替わる可能性あり。                   │
│                                                                 │
│  // 実際の実行順序が保証されない                                │
│  DoWork();                                                      │
│  Tick t = GetSystemTick();  // DoWork()より前に実行される可能性│
│  DoMoreWork();                                                  │
│                                                                 │
│  GetSystemTickOrdered() - 順序保証あり:                         │
│  ──────────────────────────────────────                         │
│  前の命令・メモリ操作完了後にティック取得。                     │
│  取得後の命令はティック取得後に実行。                           │
│                                                                 │
│  // 正確なプロファイリング                                      │
│  Tick start = GetSystemTickOrdered();                           │
│  DoExpensiveWork();                                             │
│  Tick end = GetSystemTickOrdered();                             │
│  // end - start は DoExpensiveWork() の正確な時間               │
│                                                                 │
│  用途:                                                          │
│  - GetSystemTick(): フレーム時間計測（多少の誤差許容）          │
│  - GetSystemTickOrdered(): 精密プロファイリング                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. MemoryFence - メモリバリア

### 概要

マルチコア環境でのメモリ操作順序を保証。ロックフリーアルゴリズムやDMA同期に必須。

### フェンスの種類

```
┌─────────────────────────────────────────────────────────────────┐
│ MemoryFence 9種類                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  名前形式: FenceMemory{前の操作}{後の操作}()                    │
│                                                                 │
│  ┌──────────────────────┬───────────────────────────────────┐  │
│  │ 関数                  │ 保証内容                          │  │
│  ├──────────────────────┼───────────────────────────────────┤  │
│  │ FenceMemoryStoreStore │ Store→Store の順序保証           │  │
│  │ FenceMemoryStoreLoad  │ Store→Load の順序保証            │  │
│  │ FenceMemoryStoreAny   │ Store→Store/Load の順序保証      │  │
│  │ FenceMemoryLoadStore  │ Load→Store の順序保証            │  │
│  │ FenceMemoryLoadLoad   │ Load→Load の順序保証             │  │
│  │ FenceMemoryLoadAny    │ Load→Store/Load の順序保証       │  │
│  │ FenceMemoryAnyStore   │ Store/Load→Store の順序保証      │  │
│  │ FenceMemoryAnyLoad    │ Store/Load→Load の順序保証       │  │
│  │ FenceMemoryAnyAny     │ 全操作の順序保証（フルバリア）    │  │
│  └──────────────────────┴───────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 使用例: ロックフリーキュー

```
┌─────────────────────────────────────────────────────────────────┐
│ Producer-Consumer パターン                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Producer:                                                      │
│  ─────────                                                      │
│  // 1. データを書き込む                                         │
│  buffer[writeIndex] = data;                                     │
│                                                                 │
│  // 2. Store-Store フェンス                                     │
│  FenceMemoryStoreStore();                                       │
│  // データ書き込みが完了してからインデックス更新                │
│                                                                 │
│  // 3. インデックスを更新（Consumerへの公開）                   │
│  writeIndex = nextIndex;                                        │
│                                                                 │
│                                                                 │
│  Consumer:                                                      │
│  ─────────                                                      │
│  // 1. インデックスを読む                                       │
│  int index = writeIndex;                                        │
│                                                                 │
│  // 2. Load-Load フェンス                                       │
│  FenceMemoryLoadLoad();                                         │
│  // インデックス読み取り後にデータを読む                        │
│                                                                 │
│  // 3. データを読む                                             │
│  data = buffer[index];                                          │
│                                                                 │
│                                                                 │
│  フェンスなしの場合の問題:                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ CPUの投機的実行により:                                   │   │
│  │ - Producerのインデックス更新がデータ書き込みより先       │   │
│  │ - Consumerのデータ読み取りがインデックス読み取りより先   │   │
│  │ → 未初期化データを読んでしまう可能性                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. UnitHeap - 固定サイズブロックアロケータ

### 概要

同一サイズのブロックを高速に確保・解放するヒープ。フラグメンテーションなし、O(1)操作。

### メモリレイアウト

```
┌─────────────────────────────────────────────────────────────────┐
│ UnitHeap 構造                                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CreateUnitHeap(startAddr, totalSize, unitSize=64, options)     │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ HeapCommonHead │ Unit │ Unit │ Unit │ Unit │ ... │ Unit │   │
│  │   (管理領域)   │  0   │  1   │  2   │  3   │     │  N   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                   │◄─────────────────────────────────────►│    │
│                         全ユニット同一サイズ (64 bytes)         │
│                                                                 │
│  フリーリスト（内部）:                                          │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ FreeList ──► Unit 0 ──► Unit 2 ──► Unit 5 ──► NULL      │  │
│  │              (空き)     (空き)     (空き)                │  │
│  │                                                          │  │
│  │ Unit 1, 3, 4 は使用中                                    │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  確保: O(1) - フリーリスト先頭をポップ                          │
│  解放: O(1) - フリーリスト先頭にプッシュ                        │
│  フラグメンテーション: なし（全ブロック同サイズ）               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### API

```
┌─────────────────────────────────────────────────────────────────┐
│ UnitHeap API                                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  生成・破棄:                                                    │
│  ───────────                                                    │
│  HeapHandle CreateUnitHeap(                                     │
│      void* startAddress,  // メモリ領域                         │
│      size_t size,         // 総サイズ                           │
│      size_t unitSize,     // 1ブロックのサイズ                  │
│      int option           // CreationOption                     │
│  );                                                             │
│  void DestroyUnitHeap(HeapHandle handle);                       │
│                                                                 │
│  確保・解放:                                                    │
│  ───────────                                                    │
│  void* AllocateFromUnitHeap(HeapHandle handle);                 │
│  void FreeToUnitHeap(HeapHandle handle, void* block);           │
│                                                                 │
│  情報取得:                                                      │
│  ─────────                                                      │
│  size_t GetUnitHeapUnitSize(HeapHandle handle);                 │
│  int GetUnitHeapAllocatableCount(HeapHandle handle);  // 空き数│
│  int GetUnitHeapAllocatedCount(HeapHandle handle);    // 使用数│
│                                                                 │
│  サイズ計算:                                                    │
│  ───────────                                                    │
│  size_t GetRequiredUnitHeapSize(                                │
│      size_t unitSize,                                           │
│      int unitNum,           // 必要ユニット数                   │
│      int alignment,                                             │
│      bool hasHeadInternally // 管理領域を内部に持つか           │
│  );                                                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### CreationOption

```
┌─────────────────────────────────────────────────────────────────┐
│ ヒープ作成オプション                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CreationOption_NoOption     // オプションなし                  │
│  CreationOption_ZeroClear    // 確保時にゼロクリア              │
│  CreationOption_DebugFill    // デバッグ用フィルパターン        │
│  CreationOption_ThreadSafe   // マルチスレッド対応              │
│                                                                 │
│  DebugFill パターン:                                            │
│  ┌────────────────┬────────────┐                               │
│  │ タイミング      │ フィル値   │                               │
│  ├────────────────┼────────────┤                               │
│  │ ヒープ作成時    │ 0xC3C3C3C3 │                               │
│  │ メモリ確保時    │ 0xF3F3F3F3 │                               │
│  │ メモリ解放時    │ 0xD3D3D3D3 │                               │
│  └────────────────┴────────────┘                               │
│                                                                 │
│  // 複数オプションの組み合わせ                                  │
│  int options = CreationOption_ZeroClear |                       │
│                CreationOption_ThreadSafe;                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ECSでの活用: Entity/Componentプール

```
┌─────────────────────────────────────────────────────────────────┐
│ UnitHeapによるECSエンティティ管理                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // エンティティ構造体（固定サイズ）                            │
│  struct EntitySlot {                                            │
│      EntityId id;                                               │
│      uint32_t generation;                                       │
│      ArchetypeId archetype;                                     │
│      uint32_t indexInChunk;                                     │
│  };  // 16 bytes                                                │
│                                                                 │
│  // 最大10万エンティティ用ヒープ                                │
│  size_t heapSize = GetRequiredUnitHeapSize(                     │
│      sizeof(EntitySlot), 100000, alignof(EntitySlot), true);    │
│                                                                 │
│  void* memory = malloc(heapSize);                               │
│  HeapHandle entityHeap = CreateUnitHeap(                        │
│      memory, heapSize, sizeof(EntitySlot),                      │
│      CreationOption_ThreadSafe);                                │
│                                                                 │
│  // エンティティ生成: O(1)                                      │
│  EntitySlot* slot = (EntitySlot*)AllocateFromUnitHeap(entityHeap);
│                                                                 │
│  // エンティティ破棄: O(1)                                      │
│  FreeToUnitHeap(entityHeap, slot);                              │
│                                                                 │
│  利点:                                                          │
│  - フラグメンテーションなし                                     │
│  - 確保/解放が常にO(1)                                          │
│  - ThreadSafeオプションでマルチスレッド対応                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. ExpHeap - 汎用ヒープ

### 概要

可変サイズブロックを確保できる汎用ヒープ。FirstFit/BestFitアルゴリズム選択可能。

### メモリレイアウト

```
┌─────────────────────────────────────────────────────────────────┐
│ ExpHeap 構造                                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │Head│ Block A │ Free │ Block B │ Block C │  Free  │      │   │
│  │    │ (128B)  │(64B) │ (256B)  │ (32B)   │ (512B) │      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  各ブロックはヘッダを持つ:                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ BlockHeader │           User Data                       │   │
│  │  - size     │                                           │   │
│  │  - prev     │                                           │   │
│  │  - next     │                                           │   │
│  │  - groupId  │                                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### AllocationMode

```
┌─────────────────────────────────────────────────────────────────┐
│ 確保アルゴリズム選択                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  AllocationMode_FirstFit（デフォルト）:                         │
│  ──────────────────────────────────────                         │
│  最初に見つかった十分なサイズの空き領域を使用                   │
│                                                                 │
│  要求: 100 bytes                                                │
│  ┌────────┬───────────┬────────┬─────────────────┐             │
│  │ Used   │ Free(64B) │ Used   │ Free(200B) ←使用│             │
│  └────────┴───────────┴────────┴─────────────────┘             │
│                          ↑ 64B < 100B なのでスキップ            │
│                                                                 │
│  特徴: 高速、ただしフラグメンテーションしやすい                 │
│                                                                 │
│                                                                 │
│  AllocationMode_BestFit:                                        │
│  ──────────────────────                                         │
│  要求サイズに最も近い空き領域を使用                             │
│                                                                 │
│  要求: 100 bytes                                                │
│  ┌────────┬────────────┬────────┬───────────────┐              │
│  │ Used   │ Free(120B) │ Used   │ Free(200B)    │              │
│  └────────┴────────────┴────────┴───────────────┘              │
│             ↑ 120B が最もフィット（使用）                       │
│                                                                 │
│  特徴: フラグメンテーション抑制、ただし検索コスト               │
│                                                                 │
│  SetExpHeapAllocationMode(heap, AllocationMode_BestFit);        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 前方/後方確保

```
┌─────────────────────────────────────────────────────────────────┐
│ 確保方向の指定                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  alignment > 0: 前方から確保                                    │
│  alignment < 0: 後方から確保（絶対値がアラインメント）          │
│                                                                 │
│  初期状態:                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │Head│                    Free Space                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  前方確保 (alignment=16):                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │Head│ Block A │              Free Space                  │   │
│  └─────────────────────────────────────────────────────────┘   │
│       └─────────► 前方から                                      │
│                                                                 │
│  後方確保 (alignment=-16):                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │Head│ Block A │         Free Space        │ Block B     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                               ◄─────────┘      │
│                                               後方から          │
│                                                                 │
│  用途:                                                          │
│  - 永続データは前方から確保                                     │
│  - 一時データは後方から確保                                     │
│  → 一時データ解放時にフラグメンテーション回避                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### GroupId によるブロック分類

```
┌─────────────────────────────────────────────────────────────────┐
│ GroupId でメモリブロックを分類                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // グループIDを設定（0-255）                                   │
│  SetExpHeapGroupId(heap, 1);  // テクスチャ用                   │
│  void* tex1 = AllocateFromExpHeap(heap, texSize);               │
│  void* tex2 = AllocateFromExpHeap(heap, texSize);               │
│                                                                 │
│  SetExpHeapGroupId(heap, 2);  // メッシュ用                     │
│  void* mesh1 = AllocateFromExpHeap(heap, meshSize);             │
│                                                                 │
│  // ブロックのグループIDを確認                                  │
│  Bit16 id = GetExpHeapGroupIdOfBlock(tex1);  // 1               │
│                                                                 │
│  // VisitExpHeapAllBlocksでグループ別に処理                     │
│  VisitExpHeapAllBlocks(heap, [](void* block, HeapHandle h, uintptr_t) {
│      if (GetExpHeapGroupIdOfBlock(block) == 1) {                │
│          // テクスチャブロックの処理                            │
│      }                                                          │
│  }, 0);                                                         │
│                                                                 │
│  用途:                                                          │
│  - リソース種別ごとのメモリ使用量追跡                           │
│  - 特定グループの一括解放検出                                   │
│  - デバッグ時のメモリリーク調査                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. ThreadPool & Executor - 非同期タスク基盤

### ThreadPool

```
┌─────────────────────────────────────────────────────────────────┐
│ ThreadPool 構造                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ThreadPool pool(memoryResource);                               │
│  pool.StartThreads(4, stackSize, priority);                     │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                      ThreadPool                          │   │
│  │                                                          │   │
│  │  ┌────────────────────────────────────────────────────┐ │   │
│  │  │              QueuingExecutor                        │ │   │
│  │  │  ┌──────────────────────────────────────────────┐  │ │   │
│  │  │  │             Task Queue (FIFO)                 │  │ │   │
│  │  │  │  [Task A] [Task B] [Task C] [Task D] ...     │  │ │   │
│  │  │  └──────────────────────────────────────────────┘  │ │   │
│  │  └────────────────────────────────────────────────────┘ │   │
│  │                         │                                │   │
│  │      ┌──────────────────┼──────────────────┐            │   │
│  │      │                  │                  │            │   │
│  │      ▼                  ▼                  ▼            │   │
│  │  ┌────────┐        ┌────────┐        ┌────────┐        │   │
│  │  │Worker 0│        │Worker 1│        │Worker 2│  ...   │   │
│  │  │Thread  │        │Thread  │        │Thread  │        │   │
│  │  └────────┘        └────────┘        └────────┘        │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  API:                                                           │
│  // 開始                                                        │
│  pool.StartThreads(threadCount, stackSize, priority);           │
│  pool.StartThreads(threadCount, stacks, stackSize, priority, cores);│
│                                                                 │
│  // Executor取得（タスク投入用）                                │
│  Executor* exec = pool.GetExecutor();                           │
│                                                                 │
│  // 終了                                                        │
│  pool.RequestThreadExit();  // 終了リクエスト                   │
│  pool.JoinThreads();        // 全スレッド終了待ち               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Executor抽象化

```
┌─────────────────────────────────────────────────────────────────┐
│ Executor パターン                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Executorはタスク実行の抽象化:                                  │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Executor (interface)                  │   │
│  │                          ▲                               │   │
│  │           ┌──────────────┼──────────────┐               │   │
│  │           │              │              │               │   │
│  │  ┌────────┴────┐  ┌──────┴─────┐  ┌─────┴──────┐       │   │
│  │  │QueuingExec. │  │FiberExec.  │  │InlineExec. │       │   │
│  │  │(ThreadPool) │  │(Fiber池)   │  │(即時実行)  │       │   │
│  │  └─────────────┘  └────────────┘  └────────────┘       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  利点:                                                          │
│  - タスク投入コードは実行方式を意識しない                       │
│  - Thread/Fiber切り替えが容易                                   │
│  - テスト時はInlineExecutorで同期実行                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Future/Promise パターン

```
┌─────────────────────────────────────────────────────────────────┐
│ 非同期結果の取得                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // タスク投入 → Future取得                                    │
│  Future<int> future = executor->Submit([]{                      │
│      return HeavyComputation();                                 │
│  });                                                            │
│                                                                 │
│  // 他の処理を実行                                              │
│  DoOtherWork();                                                 │
│                                                                 │
│  // 結果を待機・取得                                            │
│  int result = future.Get();                                     │
│                                                                 │
│                                                                 │
│  タイムライン:                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Main Thread:                                             │   │
│  │   Submit() ──────► DoOtherWork() ──────► Get() [待機]   │   │
│  │      │                                      │            │   │
│  │      │                                      │            │   │
│  │ Worker Thread:                              │            │   │
│  │      └─► HeavyComputation() ───────────────►└─ 完了     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Promiseで明示的に結果設定:                                     │
│  Promise<int> promise;                                          │
│  Future<int> future = promise.GetFuture();                      │
│                                                                 │
│  executor->Submit([&promise]{                                   │
│      int result = Compute();                                    │
│      promise.SetValue(result);  // 結果を設定                   │
│  });                                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### CancellationToken

```
┌─────────────────────────────────────────────────────────────────┐
│ タスクキャンセル                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CancellationTokenSource source;                                │
│  CancellationToken token = source.GetToken();                   │
│                                                                 │
│  executor->Submit([token]{                                      │
│      for (int i = 0; i < 1000000; ++i) {                        │
│          if (token.IsCancellationRequested()) {                 │
│              // キャンセルされた → 早期終了                     │
│              return;                                            │
│          }                                                      │
│          ProcessItem(i);                                        │
│      }                                                          │
│  });                                                            │
│                                                                 │
│  // 後でキャンセル要求                                          │
│  source.Cancel();                                               │
│                                                                 │
│  用途:                                                          │
│  - 長時間タスクの中断                                           │
│  - シーン切り替え時のアセットロードキャンセル                   │
│  - タイムアウト処理                                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. ジョブシステム設計パターン

### Thread + Fiber ハイブリッド

```
┌─────────────────────────────────────────────────────────────────┐
│ 推奨アーキテクチャ                                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Job System                            │   │
│  │                                                          │   │
│  │  ┌────────────────────────────────────────────────────┐ │   │
│  │  │                  Job Queue                          │ │   │
│  │  │  [Physics] [AI] [Animation] [Render Prep] ...      │ │   │
│  │  └────────────────────────────────────────────────────┘ │   │
│  │                         │                                │   │
│  │      ┌──────────────────┼──────────────────┐            │   │
│  │      ▼                  ▼                  ▼            │   │
│  │  ┌────────────────────────────────────────────────────┐ │   │
│  │  │              Worker Threads (CPU Core数)           │ │   │
│  │  │                                                    │ │   │
│  │  │  Thread 0          Thread 1          Thread 2      │ │   │
│  │  │  ┌──────────┐      ┌──────────┐      ┌──────────┐ │ │   │
│  │  │  │ Fiber A  │      │ Fiber D  │      │ Fiber G  │ │ │   │
│  │  │  │ Fiber B  │      │ Fiber E  │      │ Fiber H  │ │ │   │
│  │  │  │ Fiber C  │      │ Fiber F  │      │ Fiber I  │ │ │   │
│  │  │  └──────────┘      └──────────┘      └──────────┘ │ │   │
│  │  │                                                    │ │   │
│  │  └────────────────────────────────────────────────────┘ │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  設計指針:                                                      │
│  - Worker Thread数 = 物理コア数（ハイパースレッドは無視）      │
│  - 各ThreadでFiberを使ってジョブを切り替え                      │
│  - ジョブが待機状態になったら別のFiberに切り替え               │
│  - スレッドは常に動作（アイドル時間最小化）                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### メモリ戦略

```
┌─────────────────────────────────────────────────────────────────┐
│ ヒープの使い分け                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌────────────────────┬────────────────────────────────────┐   │
│  │ ヒープ種類          │ 用途                               │   │
│  ├────────────────────┼────────────────────────────────────┤   │
│  │ UnitHeap           │ ECSエンティティスロット            │   │
│  │                    │ ジョブ構造体                       │   │
│  │                    │ イベント構造体                     │   │
│  ├────────────────────┼────────────────────────────────────┤   │
│  │ FrameHeap          │ フレーム内一時データ               │   │
│  │                    │ 描画コマンドバッファ               │   │
│  │                    │ 一時計算結果                       │   │
│  ├────────────────────┼────────────────────────────────────┤   │
│  │ ExpHeap            │ アセットデータ（可変サイズ）       │   │
│  │                    │ テクスチャ、メッシュ、サウンド     │   │
│  │                    │ 長寿命オブジェクト                 │   │
│  └────────────────────┴────────────────────────────────────┘   │
│                                                                 │
│  メモリレイアウト例:                                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Engine Memory (例: 256MB)                                │   │
│  │ ┌─────────────────────────────────────────────────────┐ │   │
│  │ │ ExpHeap (Assets)                             192MB  │ │   │
│  │ ├─────────────────────────────────────────────────────┤ │   │
│  │ │ UnitHeap (Entities)                           16MB  │ │   │
│  │ ├─────────────────────────────────────────────────────┤ │   │
│  │ │ UnitHeap (Jobs)                                8MB  │ │   │
│  │ ├─────────────────────────────────────────────────────┤ │   │
│  │ │ FrameHeap (Frame 0)                           16MB  │ │   │
│  │ ├─────────────────────────────────────────────────────┤ │   │
│  │ │ FrameHeap (Frame 1)                           16MB  │ │   │
│  │ └─────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 参照元

- `NS/OS/Fiber.h`, `FiberApi.h`
- `NS/OS/Barrier.h`, `BarrierApi.h`
- `NS/OS/Tick.h`, `TickApi.h`
- `NS/OS/MemoryFence.h`, `MemoryFenceApi.h`
- `NS/OS/Mutex.h`, `BusyMutex.h`, `ReaderWriterLock.h`
- `NS/Lmem/UnitHeap.h`
- `NS/Lmem/ExpHeap.h`
- `NS/Async/ThreadPool.h`
- `NS/Async/Executor.h`
- `NS/Async/Future.h`
