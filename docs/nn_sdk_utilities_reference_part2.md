# NS SDK ユーティリティ リファレンス Part 2

追加のユーティリティ群の詳細解説。ECSエンジン開発に特に有用なデータ構造とメモリ管理ツール。

---

## 目次

1. [IntrusiveList - ゼロアロケーション双方向リスト](#1-intrusivelist---ゼロアロケーション双方向リスト)
2. [PlacementArray - 外部メモリ配置配列](#2-placementarray---外部メモリ配置配列)
3. [BitArray - 固定長ビット配列](#3-bitarray---固定長ビット配列)
4. [MemorySplitter - メモリレイアウト計算](#4-memorysplitter---メモリレイアウト計算)
5. [FrameHeap - フレームベーススタックアロケータ](#5-frameheap---フレームベーススタックアロケータ)
6. [BytePtr - バイト単位ポインタ演算](#6-byteptr---バイト単位ポインタ演算)
7. [ScopeExit - RAIIスコープ終了ハンドラ](#7-scopeexit---raiiスコープ終了ハンドラ)
8. [IntUtil - オーバーフロー安全整数演算](#8-intutil---オーバーフロー安全整数演算)

---

## 1. IntrusiveList - ゼロアロケーション双方向リスト

### 概要

要素自身がリンクノードを持つ侵入型双方向リスト。`std::list`と異なり、要素追加時にメモリ確保が発生しない。

### メモリレイアウト

```
┌─────────────────────────────────────────────────────────────────┐
│ std::list<T> の場合（各要素でノード確保）                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                  │
│  │ ListNode │    │ ListNode │    │ ListNode │   ← 動的確保     │
│  │ ┌──────┐ │    │ ┌──────┐ │    │ ┌──────┐ │                  │
│  │ │ prev │─┼────┼─│ prev │─┼────┼─│ prev │ │                  │
│  │ │ next │─┼────┼─│ next │─┼────┼─│ next │ │                  │
│  │ │ data │ │    │ │ data │ │    │ │ data │ │                  │
│  │ └──────┘ │    │ └──────┘ │    │ └──────┘ │                  │
│  └──────────┘    └──────────┘    └──────────┘                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ IntrusiveList<T> の場合（ノードは要素内に埋め込み）              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │     Element     │  │     Element     │  │     Element     │ │
│  │ ┌─────────────┐ │  │ ┌─────────────┐ │  │ ┌─────────────┐ │ │
│  │ │    data     │ │  │ │    data     │ │  │ │    data     │ │ │
│  │ ├─────────────┤ │  │ ├─────────────┤ │  │ ├─────────────┤ │ │
│  │ │ IntrusiveL- │ │  │ │ IntrusiveL- │ │  │ │ IntrusiveL- │ │ │
│  │ │ istNode     │◄├──┼─│ istNode     │◄├──┼─│ istNode     │ │ │
│  │ │  prev/next  │─┼──┼►│  prev/next  │─┼──┼►│  prev/next  │ │ │
│  │ └─────────────┘ │  │ └─────────────┘ │  │ └─────────────┘ │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
│        ↑                                                       │
│        └── 既存オブジェクト内にノードが存在                     │
│            追加時のメモリ確保不要                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### NodeTraits パターン

要素とノードの関係を定義する2つのパターン：

```
┌─────────────────────────────────────────────────────────────────┐
│ パターン1: IntrusiveListMemberNodeTraits（メンバとしてノード）   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  class Actor {                                                  │
│      int m_id;                                                  │
│      Vector3 m_position;                                        │
│      IntrusiveListNode m_listNode;  ← ノードはメンバ変数       │
│  };                                                             │
│                                                                 │
│  ┌────────────────────────────────┐                            │
│  │           Actor                │                            │
│  │  offset 0:  m_id               │                            │
│  │  offset 4:  m_position (12B)   │                            │
│  │  offset 16: m_listNode ◄───────┼── NodeTraitsはoffsetで     │
│  │             prev               │   ノード位置を計算         │
│  │             next               │                            │
│  └────────────────────────────────┘                            │
│                                                                 │
│  // Traits定義                                                  │
│  using ActorListTraits = IntrusiveListMemberNodeTraits<         │
│      Actor,                                                     │
│      &Actor::m_listNode                                         │
│  >;                                                             │
│                                                                 │
│  // ノード→要素の変換: ポインタ演算 (node_addr - offset)       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ パターン2: IntrusiveListBaseNodeTraits（継承でノード）          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  class Actor : public IntrusiveListNode {  ← 継承             │
│      int m_id;                                                  │
│      Vector3 m_position;                                        │
│  };                                                             │
│                                                                 │
│  ┌────────────────────────────────┐                            │
│  │           Actor                │                            │
│  │  offset 0:  IntrusiveListNode  │ ← 基底クラス部分          │
│  │             prev               │                            │
│  │             next               │                            │
│  │  offset 16: m_id               │                            │
│  │  offset 20: m_position         │                            │
│  └────────────────────────────────┘                            │
│                                                                 │
│  // Traits定義                                                  │
│  using ActorListTraits = IntrusiveListBaseNodeTraits<Actor>;    │
│                                                                 │
│  // ノード→要素の変換: static_cast<Actor*>(node)              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### NodeTraits 内部実装

```cpp
// MemberNodeTraitsの核心: offsetof相当の計算
template<class T, IntrusiveListNode T::*Member>
struct IntrusiveListMemberNodeTraits {
    static IntrusiveListNode* GetNode(T* element) {
        return &(element->*Member);  // メンバポインタでアクセス
    }

    static T* GetElement(IntrusiveListNode* node) {
        // node_address - member_offset = element_address
        // ポインタ演算で要素の先頭アドレスを算出
        return /* offsetof計算によるポインタ演算 */;
    }
};

// BaseNodeTraitsの核心: 単純なキャスト
template<class T>
struct IntrusiveListBaseNodeTraits {
    static IntrusiveListNode* GetNode(T* element) {
        return static_cast<IntrusiveListNode*>(element);
    }

    static T* GetElement(IntrusiveListNode* node) {
        return static_cast<T*>(node);  // ダウンキャスト
    }
};
```

### 複数リストへの所属

```
┌─────────────────────────────────────────────────────────────────┐
│ 1つの要素が複数のリストに同時所属可能                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  class Actor {                                                  │
│      IntrusiveListNode m_activeListNode;   // アクティブリスト用│
│      IntrusiveListNode m_renderListNode;   // 描画リスト用     │
│      IntrusiveListNode m_physicsListNode;  // 物理リスト用     │
│  };                                                             │
│                                                                 │
│  ┌──────────────┐                                              │
│  │    Actor     │                                              │
│  │  ┌────────┐  │◄────── ActiveList                            │
│  │  │ node1  │──┼──────► (prev/next)                           │
│  │  ├────────┤  │                                              │
│  │  │ node2  │──┼──────► RenderList                            │
│  │  ├────────┤  │        (prev/next)                           │
│  │  │ node3  │──┼──────► PhysicsList                           │
│  │  └────────┘  │        (prev/next)                           │
│  └──────────────┘                                              │
│                                                                 │
│  // 各リストに異なるTraitsを定義                                │
│  using ActiveListTraits = MemberNodeTraits<Actor, &Actor::m_activeListNode>;  │
│  using RenderListTraits = MemberNodeTraits<Actor, &Actor::m_renderListNode>;  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ECSでの活用例

```
┌─────────────────────────────────────────────────────────────────┐
│ フリーリスト管理（Chunk内の空きエントリ追跡）                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Chunk (16KB)                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ [Entity0] [Entity1] [  FREE  ] [Entity3] [  FREE  ]     │   │
│  │              ↑          │                    │          │   │
│  │              │          └────────────────────┘          │   │
│  │              │                   │                      │   │
│  │              │                   ▼                      │   │
│  │           m_freeList ──► FreeEntry ──► FreeEntry ──►null│   │
│  │                           (node)        (node)          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  // 空きエントリの再利用がO(1)                                  │
│  // メモリ確保なしでフリーリスト管理                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. PlacementArray - 外部メモリ配置配列

### 概要

外部から提供されたメモリ領域上に固定長配列を構築する。配列自体はメモリ確保を行わず、要素のライフサイクルを手動管理。

### メモリモデル

```
┌─────────────────────────────────────────────────────────────────┐
│ std::vector<T> vs PlacementArray<T>                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  std::vector<T>:                                                │
│  ┌──────────┐      ┌─────────────────────────────────┐         │
│  │ m_data ──┼─────►│ T │ T │ T │ T │ ... │ capacity  │         │
│  │ m_size   │      └─────────────────────────────────┘         │
│  │ m_cap    │           ↑ vectorが内部で確保・管理             │
│  └──────────┘                                                   │
│                                                                 │
│  PlacementArray<T>:                                             │
│  ┌──────────┐                                                   │
│  │ m_data ──┼─────►┌─────────────────────────────────┐         │
│  │ m_size   │      │         外部提供メモリ          │         │
│  │ m_cap    │      └─────────────────────────────────┘         │
│  └──────────┘           ↑ ユーザーが確保・管理                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 初期化フロー

```
┌─────────────────────────────────────────────────────────────────┐
│ PlacementArrayの使用手順                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Step 1: 必要メモリサイズを計算                                 │
│  ────────────────────────────────                               │
│  size_t size = PlacementArray<MyType>::CalculateWorkMemorySize( │
│      elementCount,     // 要素数                                │
│      alignof(MyType)   // アラインメント                        │
│  );                                                             │
│                                                                 │
│  Step 2: メモリを確保（任意のアロケータ使用可能）               │
│  ──────────────────────────────────────────────                 │
│  void* memory = myAllocator.Allocate(size, alignof(MyType));    │
│                                                                 │
│  Step 3: 配列を初期化                                           │
│  ──────────────────                                             │
│  PlacementArray<MyType> array;                                  │
│  array.ResetWorkMemory(memory, size, elementCount);             │
│                                                                 │
│  Step 4: 要素を構築（手動でplacement new）                      │
│  ─────────────────────────────────────────                      │
│  for (int i = 0; i < count; ++i) {                              │
│      new (&array[i]) MyType(args...);  // placement new        │
│  }                                                              │
│                                                                 │
│  Step 5: 使用終了時は手動でデストラクタ呼び出し                 │
│  ─────────────────────────────────────────────                  │
│  for (int i = 0; i < count; ++i) {                              │
│      array[i].~MyType();                                        │
│  }                                                              │
│                                                                 │
│  Step 6: メモリ解放（確保元で）                                 │
│  ──────────────────────────────                                 │
│  myAllocator.Free(memory);                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### PtrPlacementArray - ポインタ配列特殊化

```
┌─────────────────────────────────────────────────────────────────┐
│ PtrPlacementArray<T>: ポインタ配列に特化                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // 内部的には PlacementArray<T*> と同等だが                    │
│  // ポインタのサイズ・アラインメントが固定のため最適化可能      │
│                                                                 │
│  ┌─────────────────────────────────────────────────────┐       │
│  │ T* │ T* │ T* │ T* │ T* │ ... │ T* │               │       │
│  └─────────────────────────────────────────────────────┘       │
│    ↓    ↓    ↓    ↓    ↓         ↓                            │
│  ┌───┐┌───┐┌───┐┌───┐┌───┐    ┌───┐                          │
│  │Obj││Obj││Obj││Obj││Obj│    │Obj│  実際のオブジェクト       │
│  └───┘└───┘└───┘└───┘└───┘    └───┘  (どこにあってもよい)     │
│                                                                 │
│  // ソートやシャッフルが高速（ポインタのみ移動）                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ECSでの活用

```
┌─────────────────────────────────────────────────────────────────┐
│ Chunk内コンポーネント配列としての利用                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Archetype定義時:                                               │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Position配列サイズ = CalculateWorkMemorySize(maxEntities) │  │
│  │ Velocity配列サイズ = CalculateWorkMemorySize(maxEntities) │  │
│  │ Total = Position + Velocity + padding                     │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  Chunk (16KB固定):                                              │
│  ┌────────────────────────────────────────────────────────┐    │
│  │ Header │ PlacementArray<Position> │ PlacementArray<Vel>│    │
│  │        │ [P0][P1][P2][P3]...      │ [V0][V1][V2][V3]..│    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  利点:                                                          │
│  - Chunk全体を一括確保、内部で分割                              │
│  - 配列自体のオーバーヘッドなし（ポインタと長さのみ）           │
│  - キャッシュ効率の良いSoAレイアウト実現                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. BitArray - 固定長ビット配列

### 概要

固定長のビット配列。個別ビットへのアクセス、範囲操作、ビット走査を効率的に行う。

### メモリレイアウト

```
┌─────────────────────────────────────────────────────────────────┐
│ BitArray<64> のメモリ構造                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  論理的なビット配置:                                            │
│  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬───┬─┬─┐   │
│  │0│1│2│3│4│5│6│7│8│9│...                              │62│63│  │
│  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴───┴─┴─┘   │
│                                                                 │
│  物理的なメモリ配置 (uint64_t単位):                             │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │                    uint64_t m_storage[1]                  │ │
│  │  bit 0-63 packed into single 64-bit word                  │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  BitArray<128> の場合:                                          │
│  ┌─────────────────────────────┬─────────────────────────────┐ │
│  │      uint64_t m_storage[0]  │      uint64_t m_storage[1]  │ │
│  │        bit 0-63             │        bit 64-127           │ │
│  └─────────────────────────────┴─────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Reference Proxy パターン

```
┌─────────────────────────────────────────────────────────────────┐
│ 個別ビットへのアクセス機構                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // operator[] は reference proxy を返す                        │
│  auto bit = bitArray[5];  // reference型                        │
│                                                                 │
│  ┌──────────────────────────────────────────────────────┐      │
│  │              reference (proxy class)                 │      │
│  │  ┌────────────────┐  ┌────────────────┐             │      │
│  │  │ BitArray* ptr  │  │ size_t index   │             │      │
│  │  └───────┬────────┘  └───────┬────────┘             │      │
│  │          │                   │                       │      │
│  │          ▼                   ▼                       │      │
│  │  operator bool() const {                             │      │
│  │      return ptr->test(index);                        │      │
│  │  }                                                   │      │
│  │                                                      │      │
│  │  reference& operator=(bool value) {                  │      │
│  │      if (value) ptr->set(index);                     │      │
│  │      else       ptr->reset(index);                   │      │
│  │      return *this;                                   │      │
│  │  }                                                   │      │
│  └──────────────────────────────────────────────────────┘      │
│                                                                 │
│  // 使用例                                                      │
│  bitArray[5] = true;   // proxy経由でset                        │
│  bool v = bitArray[5]; // proxy経由でtest                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 主要操作

```
┌─────────────────────────────────────────────────────────────────┐
│ BitArray操作一覧                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  個別ビット操作:                                                │
│  ───────────────                                                │
│  set(index)      // ビットを1にセット                           │
│  reset(index)    // ビットを0にリセット                         │
│  flip(index)     // ビットを反転                                │
│  test(index)     // ビット値を取得                              │
│                                                                 │
│  全体操作:                                                      │
│  ─────────                                                      │
│  set()           // 全ビットを1に                               │
│  reset()         // 全ビットを0に                               │
│  flip()          // 全ビットを反転                              │
│                                                                 │
│  クエリ:                                                        │
│  ────────                                                       │
│  count()         // 1のビット数をカウント (popcount)            │
│  all()           // 全ビットが1か                               │
│  any()           // いずれかのビットが1か                       │
│  none()          // 全ビットが0か                               │
│                                                                 │
│  反復:                                                          │
│  ──────                                                         │
│  ForeachIfOne([](size_t index) {                                │
│      // 1がセットされているindexのみコールバック                │
│  });                                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ECSでの活用

```
┌─────────────────────────────────────────────────────────────────┐
│ ComponentMask: Archetypeが持つコンポーネントの表現              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // 各コンポーネント型にIDを割り当て                            │
│  enum ComponentId { Position=0, Velocity=1, Sprite=2, ... };    │
│                                                                 │
│  Archetype A (Position + Velocity):                             │
│  ┌─┬─┬─┬─┬─┬─┬─┬─┬───┐                                         │
│  │1│1│0│0│0│0│0│0│...│  componentMask                          │
│  └─┴─┴─┴─┴─┴─┴─┴─┴───┘                                         │
│   ↑ ↑                                                           │
│   │ └─ Velocity (ID=1)                                          │
│   └─── Position (ID=0)                                          │
│                                                                 │
│  Query "Position & Velocity & !Sprite":                         │
│  ┌─┬─┬─┬─┬─┬─┬─┬─┬───┐                                         │
│  │1│1│0│0│0│0│0│0│...│  includeMask                            │
│  └─┴─┴─┴─┴─┴─┴─┴─┴───┘                                         │
│  ┌─┬─┬─┬─┬─┬─┬─┬─┬───┐                                         │
│  │0│0│1│0│0│0│0│0│...│  excludeMask                            │
│  └─┴─┴─┴─┴─┴─┴─┴─┴───┘                                         │
│                                                                 │
│  マッチング:                                                    │
│  (archetype.mask & query.include) == query.include              │
│  (archetype.mask & query.exclude) == 0                          │
│                                                                 │
│  → ビット演算で高速にArchetypeをフィルタリング                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. MemorySplitter - メモリレイアウト計算

### 概要

複数のメモリブロックを連続領域に配置する際のオフセット計算を自動化。アラインメントとバイアスを考慮したレイアウト設計。

### 基本概念

```
┌─────────────────────────────────────────────────────────────────┐
│ MemorySplitterの役割                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  問題: 異なるサイズ・アラインメントのデータを                   │
│        1つの連続メモリ領域に効率よく配置したい                  │
│                                                                 │
│  入力:                                                          │
│  ┌─────────────────────┐                                       │
│  │ Block A: 12 bytes   │ align=4                               │
│  │ Block B: 64 bytes   │ align=16                              │
│  │ Block C: 8 bytes    │ align=8                               │
│  └─────────────────────┘                                       │
│                                                                 │
│  出力 (MemorySplitterが計算):                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ offset=0      offset=16     offset=80      total=88     │   │
│  │ ┌──────────┐  ┌───────────────────────┐  ┌──────────┐   │   │
│  │ │ Block A  │pp│      Block B          │  │ Block C  │   │   │
│  │ │ 12 bytes │  │      64 bytes         │  │ 8 bytes  │   │   │
│  │ └──────────┘  └───────────────────────┘  └──────────┘   │   │
│  │              ↑                                           │   │
│  │              └─ padding for alignment                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### MemoryBlock構造

```
┌─────────────────────────────────────────────────────────────────┐
│ MemoryBlock の設定項目                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  MemoryBlock block;                                             │
│                                                                 │
│  // サイズ設定（3つの方法）                                     │
│  block.SetSizeBy<MyType>();           // sizeof(MyType)        │
│  block.SetSizeBy<MyType>(count);      // sizeof(MyType) * count│
│  block.SetSize(byteSize);             // 直接指定               │
│                                                                 │
│  // アラインメント設定                                          │
│  block.SetAlignment(alignment);        // 通常                  │
│  block.SetAlignment(alignment, bias);  // バイアス付き          │
│                                                                 │
│  // 結果取得（Append後）                                        │
│  size_t offset = block.GetPosition();  // 先頭からのオフセット │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### アラインメントバイアス

```
┌─────────────────────────────────────────────────────────────────┐
│ バイアス付きアラインメント                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  通常のアラインメント (bias=0):                                 │
│  ────────────────────────────────                               │
│  アドレス % alignment == 0                                      │
│                                                                 │
│  例: alignment=16, bias=0                                       │
│  有効アドレス: 0, 16, 32, 48, 64, ...                           │
│                                                                 │
│  バイアス付きアラインメント:                                    │
│  ──────────────────────────                                     │
│  アドレス % alignment == bias                                   │
│                                                                 │
│  例: alignment=16, bias=4                                       │
│  有効アドレス: 4, 20, 36, 52, 68, ...                           │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  0   4   8   12  16  20  24  28  32  36  40  44  48     │   │
│  │  │   ●   │   │   │   ●   │   │   │   ●   │   │   │     │   │
│  │      ↑           ↑           ↑                          │   │
│  │      └───────────┴───────────┴── bias=4 のアライン位置  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  用途: CPUキャッシュライン内の特定位置への配置など              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 使用例

```cpp
// Chunk内レイアウトの計算例
MemorySplitter splitter;

MemoryBlock headerBlock;
headerBlock.SetSizeBy<ChunkHeader>();
headerBlock.SetAlignment(alignof(ChunkHeader));

MemoryBlock positionBlock;
positionBlock.SetSizeBy<Position>(maxEntities);
positionBlock.SetAlignment(alignof(Position));

MemoryBlock velocityBlock;
velocityBlock.SetSizeBy<Velocity>(maxEntities);
velocityBlock.SetAlignment(alignof(Velocity));

// チェーン形式でAppend
splitter.Append(&headerBlock)
        .Append(&positionBlock)
        .Append(&velocityBlock);

// 結果取得
size_t totalSize = splitter.GetTotalSize();
size_t headerOffset = headerBlock.GetPosition();    // 0
size_t positionOffset = positionBlock.GetPosition(); // sizeof(ChunkHeader) + padding
size_t velocityOffset = velocityBlock.GetPosition(); // positionOffset + Position配列 + padding
```

---

## 5. FrameHeap - フレームベーススタックアロケータ

### 概要

スタック型のメモリアロケータ。前方・後方両端から確保可能で、フレーム単位での一括解放や状態の保存・復元に対応。

### メモリモデル

```
┌─────────────────────────────────────────────────────────────────┐
│ FrameHeapのメモリ構造                                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  初期状態:                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    利用可能領域                          │   │
│  │◄────────────────────────────────────────────────────────►│   │
│  └─────────────────────────────────────────────────────────┘   │
│  ↑ frontHead                                         rearHead ↑ │
│                                                                 │
│  前方から確保 (alignment > 0):                                  │
│  ┌────────┬────────────────────────────────────────────────┐   │
│  │ Alloc1 │               利用可能領域                     │   │
│  └────────┴────────────────────────────────────────────────┘   │
│           ↑ frontHead                                           │
│                                                                 │
│  後方から確保 (alignment < 0):                                  │
│  ┌────────┬────────────────────────────────┬───────────────┐   │
│  │ Alloc1 │         利用可能領域           │    Alloc2     │   │
│  └────────┴────────────────────────────────┴───────────────┘   │
│           ↑ frontHead                       rearHead ↑         │
│                                                                 │
│  さらに確保:                                                    │
│  ┌────────┬────────┬──────────────┬────────┬───────────────┐   │
│  │ Alloc1 │ Alloc3 │  利用可能    │ Alloc4 │    Alloc2     │   │
│  └────────┴────────┴──────────────┴────────┴───────────────┘   │
│                    ↑ frontHead    rearHead ↑                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 解放モード

```
┌─────────────────────────────────────────────────────────────────┐
│ FreeToFrameHeap の3つのモード                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  現在の状態:                                                    │
│  ┌────────┬────────┬──────────────┬────────┬───────────────┐   │
│  │ Alloc1 │ Alloc2 │              │ Alloc4 │    Alloc3     │   │
│  └────────┴────────┴──────────────┴────────┴───────────────┘   │
│                                                                 │
│  FreeMode_Front (前方のみ解放):                                 │
│  ┌────────────────────────────────┬────────┬───────────────┐   │
│  │           利用可能             │ Alloc4 │    Alloc3     │   │
│  └────────────────────────────────┴────────┴───────────────┘   │
│  ↑ frontHead リセット                                          │
│                                                                 │
│  FreeMode_Rear (後方のみ解放):                                  │
│  ┌────────┬────────┬──────────────────────────────────────┐    │
│  │ Alloc1 │ Alloc2 │               利用可能               │    │
│  └────────┴────────┴──────────────────────────────────────┘    │
│                                              rearHead リセット ↑│
│                                                                 │
│  FreeMode_All (両方解放):                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    利用可能領域                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ↑ frontHead                                         rearHead ↑ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 状態の保存・復元

```
┌─────────────────────────────────────────────────────────────────┐
│ FrameHeapState による状態管理                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // 現在の状態を保存                                            │
│  FrameHeapState savedState;                                     │
│  GetFrameHeapState(heap, &savedState);                          │
│                                                                 │
│  保存時:                                                        │
│  ┌────────┬────────┬──────────────┬────────┬───────────────┐   │
│  │ Alloc1 │ Alloc2 │              │ Alloc4 │    Alloc3     │   │
│  └────────┴────────┴──────────────┴────────┴───────────────┘   │
│                    ↑ saved.front  saved.rear ↑                 │
│                                                                 │
│  追加の確保:                                                    │
│  ┌────────┬────────┬────────┬────┬────────┬───────────────┐    │
│  │ Alloc1 │ Alloc2 │ Alloc5 │    │ Alloc4 │    Alloc3     │    │
│  └────────┴────────┴────────┴────┴────────┴───────────────┘    │
│                                                                 │
│  // 保存した状態に復元                                          │
│  RestoreFrameHeapState(heap, &savedState);                      │
│                                                                 │
│  復元後 (Alloc5が無効化):                                       │
│  ┌────────┬────────┬──────────────┬────────┬───────────────┐   │
│  │ Alloc1 │ Alloc2 │              │ Alloc4 │    Alloc3     │   │
│  └────────┴────────┴──────────────┴────────┴───────────────┘   │
│                                                                 │
│  用途: ゲームフレーム内の一時確保を次フレームで一括無効化      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### API一覧

```
┌─────────────────────────────────────────────────────────────────┐
│ FrameHeap API                                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  生成・破棄:                                                    │
│  ───────────                                                    │
│  HeapHandle CreateFrameHeap(void* startAddr, size_t size,       │
│                             int option);                        │
│  void DestroyFrameHeap(HeapHandle handle);                      │
│                                                                 │
│  確保:                                                          │
│  ──────                                                         │
│  void* AllocateFromFrameHeap(HeapHandle handle, size_t size,    │
│                              int alignment);                    │
│  // alignment > 0 : 前方から確保                                │
│  // alignment < 0 : 後方から確保 (絶対値がアラインメント)       │
│                                                                 │
│  解放:                                                          │
│  ──────                                                         │
│  void FreeToFrameHeap(HeapHandle handle, FreeMode mode);        │
│  // FreeMode_Front : 前方を全解放                               │
│  // FreeMode_Rear  : 後方を全解放                               │
│  // FreeMode_All   : 全解放                                     │
│                                                                 │
│  状態管理:                                                      │
│  ─────────                                                      │
│  void GetFrameHeapState(HeapHandle handle,                      │
│                         FrameHeapState* outState);              │
│  void RestoreFrameHeapState(HeapHandle handle,                  │
│                             const FrameHeapState* state);       │
│                                                                 │
│  情報取得:                                                      │
│  ─────────                                                      │
│  size_t GetFrameHeapAllocatableSize(HeapHandle handle,          │
│                                     int alignment);             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. BytePtr - バイト単位ポインタ演算

### 概要

`void*`に対するバイト単位のポインタ演算を型安全に行うユーティリティ。アドレス計算とアラインメント調整を簡潔に記述。

### 基本操作

```
┌─────────────────────────────────────────────────────────────────┐
│ BytePtrの基本機能                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // 構築                                                        │
│  BytePtr ptr(someVoidPointer);                                  │
│                                                                 │
│  // 進める                                                      │
│  ptr.Advance(64);  // 64バイト進める                            │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Memory                                                   │   │
│  │ ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐   │   │
│  │ │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │
│  │ └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘   │   │
│  │ ↑                                   ↑                    │   │
│  │ 元の位置                            Advance(64)後        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  // 距離計算                                                    │
│  BytePtr other(anotherPointer);                                 │
│  ptrdiff_t dist = ptr.Distance(other);  // バイト数で距離      │
│                                                                 │
│  // キャスト                                                    │
│  MyType* typed = ptr.Get<MyType>();  // void* → MyType*        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### アラインメント操作

```
┌─────────────────────────────────────────────────────────────────┐
│ アラインメント調整                                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  BytePtr ptr(address);  // address = 0x1005                     │
│                                                                 │
│  IsAligned(16) の結果:                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  0x1000    0x1005    0x1010    0x1020                    │   │
│  │     ↓         ↓         ↓         ↓                      │   │
│  │  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐                     │   │
│  │  │ OK  │  │ ptr │  │ OK  │  │ OK  │  16バイト境界      │   │
│  │  └─────┘  └─────┘  └─────┘  └─────┘                     │   │
│  │           ↑                                              │   │
│  │           0x1005 % 16 = 5 ≠ 0 → false                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  AlignUp(16):                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  0x1000    0x1005    0x1010                              │   │
│  │              ↓──────────►↓                               │   │
│  │           元位置      切り上げ後 (次の16境界)            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  AlignDown(16):                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  0x1000    0x1005                                        │   │
│  │     ↓◄────────↓                                          │   │
│  │  切り捨て後   元位置 (前の16境界へ)                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ConstBytePtr

```
┌─────────────────────────────────────────────────────────────────┐
│ BytePtr vs ConstBytePtr                                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  BytePtr:                                                       │
│  - void* をラップ                                               │
│  - 読み書き可能なポインタ操作                                   │
│  - Get<T>() は T* を返す                                        │
│                                                                 │
│  ConstBytePtr:                                                  │
│  - const void* をラップ                                         │
│  - 読み取り専用のポインタ操作                                   │
│  - Get<T>() は const T* を返す                                  │
│                                                                 │
│  // 使い分け                                                    │
│  void ProcessData(ConstBytePtr src, BytePtr dst, size_t size) { │
│      // srcからは読み取りのみ、dstには書き込み                  │
│  }                                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. ScopeExit - RAIIスコープ終了ハンドラ

### 概要

スコープ終了時に任意の処理を実行するRAIIヘルパー。リソース解放やクリーンアップを例外安全に行う。

### 動作原理

```
┌─────────────────────────────────────────────────────────────────┐
│ NS_UTIL_SCOPE_EXIT の展開                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  使用コード:                                                    │
│  ───────────                                                    │
│  {                                                              │
│      FILE* f = fopen("file.txt", "r");                          │
│      NS_UTIL_SCOPE_EXIT { fclose(f); };                         │
│                                                                 │
│      // 処理...                                                 │
│      if (error) return;  // ここでもfclose実行                  │
│      // 処理...                                                 │
│  }  // ← スコープ終了、fclose(f)が実行される                   │
│                                                                 │
│  マクロ展開後:                                                  │
│  ─────────────                                                  │
│  {                                                              │
│      FILE* f = fopen("file.txt", "r");                          │
│      auto _scopeExit_42 = ScopeExitHolder([&]() {               │
│          fclose(f);                                             │
│      });                                                        │
│      ...                                                        │
│  }                                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 実装構造

```
┌─────────────────────────────────────────────────────────────────┐
│ ScopeExitHolder テンプレート                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  template<typename F>                                           │
│  class ScopeExitHolder {                                        │
│      F m_func;        // ラムダを保持                           │
│      bool m_active;   // 実行するかどうか                       │
│                                                                 │
│  public:                                                        │
│      ScopeExitHolder(F&& func)                                  │
│          : m_func(std::move(func)), m_active(true) {}           │
│                                                                 │
│      ~ScopeExitHolder() {                                       │
│          if (m_active) m_func();  // デストラクタで実行         │
│      }                                                          │
│                                                                 │
│      void Dismiss() { m_active = false; }  // 実行キャンセル    │
│  };                                                             │
│                                                                 │
│  // ヘルパー関数（型推論用）                                    │
│  template<typename F>                                           │
│  ScopeExitHolder<F> MakeScopeExit(F&& func) {                   │
│      return ScopeExitHolder<F>(std::forward<F>(func));          │
│  }                                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 実用パターン

```
┌─────────────────────────────────────────────────────────────────┐
│ ScopeExitの活用パターン                                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  パターン1: リソース解放                                        │
│  ─────────────────────────                                      │
│  void* buffer = malloc(1024);                                   │
│  NS_UTIL_SCOPE_EXIT { free(buffer); };                          │
│  // 例外やearly returnがあっても必ず解放                        │
│                                                                 │
│  パターン2: 状態の復元                                          │
│  ─────────────────────────                                      │
│  auto oldState = GetState();                                    │
│  SetState(newState);                                            │
│  NS_UTIL_SCOPE_EXIT { SetState(oldState); };                    │
│  // 処理後に元の状態に戻す                                      │
│                                                                 │
│  パターン3: ロック解放                                          │
│  ─────────────────────                                          │
│  mutex.Lock();                                                  │
│  NS_UTIL_SCOPE_EXIT { mutex.Unlock(); };                        │
│  // 複数のreturnパスがあっても安全                              │
│                                                                 │
│  パターン4: フラグリセット                                      │
│  ─────────────────────────                                      │
│  m_processing = true;                                           │
│  NS_UTIL_SCOPE_EXIT { m_processing = false; };                  │
│  // 再入防止フラグの確実なリセット                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. IntUtil - オーバーフロー安全整数演算

### 概要

整数演算時のオーバーフロー検出と型間の安全な変換を提供。未定義動作を防ぎ、堅牢な数値計算を実現。

### オーバーフロー検出

```
┌─────────────────────────────────────────────────────────────────┐
│ オーバーフロー事前チェック                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  加算オーバーフロー:                                            │
│  ──────────────────                                             │
│  int32_t a = 2000000000;                                        │
│  int32_t b = 1000000000;                                        │
│                                                                 │
│  if (CanAddWithoutOverflow(a, b)) {                             │
│      int32_t result = a + b;  // 安全                           │
│  } else {                                                       │
│      // オーバーフローする → エラー処理                        │
│  }                                                              │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ INT32_MAX = 2,147,483,647                                │   │
│  │                                                          │   │
│  │ a + b = 2,000,000,000 + 1,000,000,000                    │   │
│  │       = 3,000,000,000                                    │   │
│  │                                                          │   │
│  │ 3,000,000,000 > INT32_MAX → オーバーフロー！             │   │
│  │                                                          │   │
│  │ CanAddWithoutOverflow(a, b) → false                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  同様の関数:                                                    │
│  - CanSubtractWithoutOverflow(a, b)                             │
│  - CanMultiplyWithoutOverflow(a, b)                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 試行関数（Try系）

```
┌─────────────────────────────────────────────────────────────────┐
│ TryXxxWithoutOverflow パターン                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // 成功時は結果を出力引数に設定してtrueを返す                  │
│  // 失敗時（オーバーフロー）はfalseを返す                       │
│                                                                 │
│  int32_t a = 1000000000;                                        │
│  int32_t b = 1000000000;                                        │
│  int32_t result;                                                │
│                                                                 │
│  if (TryAddWithoutOverflow(&result, a, b)) {                    │
│      // result に a + b の結果が格納されている                  │
│      UseResult(result);                                         │
│  } else {                                                       │
│      // オーバーフロー発生                                      │
│      HandleOverflow();                                          │
│  }                                                              │
│                                                                 │
│  // 連鎖的な計算にも使用可能                                    │
│  int32_t temp, final;                                           │
│  if (TryMultiplyWithoutOverflow(&temp, a, b) &&                 │
│      TryAddWithoutOverflow(&final, temp, c)) {                  │
│      // (a * b) + c を安全に計算                                │
│  }                                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 型変換の安全性チェック

```
┌─────────────────────────────────────────────────────────────────┐
│ IsIntValueRepresentable - 型間変換の安全性                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  // 値が変換先の型で表現可能かチェック                          │
│                                                                 │
│  int64_t bigValue = 5000000000LL;                               │
│                                                                 │
│  IsIntValueRepresentable<int32_t>(bigValue);  // false          │
│  // 5,000,000,000 > INT32_MAX (2,147,483,647)                   │
│                                                                 │
│  int64_t smallValue = 1000;                                     │
│  IsIntValueRepresentable<int32_t>(smallValue); // true          │
│  IsIntValueRepresentable<int16_t>(smallValue); // true          │
│  IsIntValueRepresentable<int8_t>(smallValue);  // false         │
│  // 1000 > INT8_MAX (127)                                       │
│                                                                 │
│  // 符号なし→符号ありの変換                                    │
│  uint32_t unsignedVal = 3000000000u;                            │
│  IsIntValueRepresentable<int32_t>(unsignedVal); // false        │
│  // 3,000,000,000 > INT32_MAX                                   │
│                                                                 │
│  // 負の値→符号なしの変換                                      │
│  int32_t negativeVal = -100;                                    │
│  IsIntValueRepresentable<uint32_t>(negativeVal); // false       │
│  // 負の値は符号なし型で表現不可                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### C++20 std::cmp_* バックポート

```
┌─────────────────────────────────────────────────────────────────┐
│ 符号付き/符号なし安全比較                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  問題: 符号付きと符号なしの直接比較は危険                       │
│  ───────────────────────────────────────────                    │
│                                                                 │
│  int32_t signed_val = -1;                                       │
│  uint32_t unsigned_val = 1;                                     │
│                                                                 │
│  // 直接比較（危険！）                                          │
│  if (signed_val < unsigned_val) { ... }                         │
│  // -1 が暗黙的に unsigned に変換 → 4294967295                  │
│  // 4294967295 < 1 → false（期待と逆！）                        │
│                                                                 │
│  解決策: cmp_xxx 関数を使用                                     │
│  ─────────────────────────────                                  │
│  if (cmp_less(signed_val, unsigned_val)) { ... }                │
│  // 内部で適切に処理 → true（正しい結果）                       │
│                                                                 │
│  利用可能な比較関数:                                            │
│  ┌────────────────┬──────────────────────────┐                 │
│  │ 関数           │ 同等の演算子             │                 │
│  ├────────────────┼──────────────────────────┤                 │
│  │ cmp_equal      │ ==                       │                 │
│  │ cmp_not_equal  │ !=                       │                 │
│  │ cmp_less       │ <                        │                 │
│  │ cmp_less_equal │ <=                       │                 │
│  │ cmp_greater    │ >                        │                 │
│  │ cmp_greater_eq │ >=                       │                 │
│  └────────────────┴──────────────────────────┘                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## NS-ENGINE への導入優先度

### 高優先度（ECSコア）

| ユーティリティ | 用途 |
|----------------|------|
| IntrusiveList | フリーリスト、Archetype/Chunkリンク |
| BitArray | ComponentMask、EntityExists判定 |
| PlacementArray | Chunk内SoA配列 |
| MemorySplitter | Chunkメモリレイアウト計算 |

### 中優先度（メモリ管理）

| ユーティリティ | 用途 |
|----------------|------|
| FrameHeap | フレーム単位一時アロケータ |
| BytePtr | アライメント調整、オフセット計算 |

### 低優先度（品質向上）

| ユーティリティ | 用途 |
|----------------|------|
| ScopeExit | リソースクリーンアップ |
| IntUtil | インデックス計算の安全性 |

---

## 参照元

- `NS/Util/IntrusiveList.h`
- `NS/Util/PlacementArray.h`
- `NS/Util/BitArray.h`
- `NS/Util/MemorySplitter.h`
- `NS/Lmem/FrameHeap.h`
- `NS/Util/BytePtr.h`
- `NS/Util/ScopeExit.h`
- `NS/Util/IntUtil.h`
